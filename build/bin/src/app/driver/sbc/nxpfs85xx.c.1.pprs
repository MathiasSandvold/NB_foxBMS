typedef	signed char		__int8_t;
typedef	unsigned char		__uint8_t;
typedef	short			__int16_t;
typedef	unsigned short		__uint16_t;
typedef	int			__int32_t;
typedef	unsigned int		__uint32_t;
typedef	long long		__int64_t;
typedef	unsigned long long	__uint64_t;
typedef	__uint32_t	__clock_t;
typedef	__int32_t	__critical_t;
typedef	double		__double_t;
typedef	float		__float_t;
typedef	__int32_t	__intfptr_t;
typedef	__int64_t	__intmax_t;
typedef	__int32_t	__intptr_t;
typedef	__int32_t	__int_fast8_t;
typedef	__int32_t	__int_fast16_t;
typedef	__int32_t	__int_fast32_t;
typedef	__int64_t	__int_fast64_t;
typedef	__int8_t	__int_least8_t;
typedef	__int16_t	__int_least16_t;
typedef	__int32_t	__int_least32_t;
typedef	__int64_t	__int_least64_t;
typedef	__int32_t	__ptrdiff_t;
typedef	__int32_t	__register_t;
typedef	__int32_t	__segsz_t;
typedef	__uint32_t	__size_t;
typedef	__int32_t	__ssize_t;
typedef __uint32_t      __time_t;
typedef	__uint32_t	__uintfptr_t;
typedef	__uint64_t	__uintmax_t;
typedef	__uint32_t	__uintptr_t;
typedef	__uint32_t	__uint_fast8_t;
typedef	__uint32_t	__uint_fast16_t;
typedef	__uint32_t	__uint_fast32_t;
typedef	__uint64_t	__uint_fast64_t;
typedef	__uint8_t	__uint_least8_t;
typedef	__uint16_t	__uint_least16_t;
typedef	__uint32_t	__uint_least32_t;
typedef	__uint64_t	__uint_least64_t;
typedef	__uint32_t	__u_register_t;
typedef	__uint32_t	__vm_offset_t;
typedef	__uint32_t	__vm_paddr_t;
typedef	__uint32_t	__vm_size_t;
typedef	unsigned short ___wchar_t;
typedef long _off_t;
typedef struct __va_list_t {
    void * __ap;
} __va_list;
typedef	__int32_t	__blksize_t;
typedef	__int64_t	__blkcnt_t;
typedef	__int32_t	__clockid_t;
typedef	__uint32_t	__fflags_t;
typedef	__uint64_t	__fsblkcnt_t;
typedef	__uint64_t	__fsfilcnt_t;
typedef	__uint32_t	__gid_t;
typedef	__int64_t	__id_t;
typedef	__uint64_t	__ino_t;
typedef	long		__key_t;
typedef	__int32_t	__lwpid_t;
typedef	__uint16_t	__mode_t;
typedef	int		__accmode_t;
typedef	int		__nl_item;
typedef	__uint64_t	__nlink_t;
typedef	_off_t	        __off_t;
typedef	__int64_t	__off64_t;
typedef	__int32_t	__pid_t;
typedef	__int64_t	__rlim_t;
typedef	__uint8_t	__sa_family_t;
typedef	__uint32_t	__socklen_t;
typedef	long		__suseconds_t;
typedef	struct __timer	*__timer_t;
typedef	struct __mq	*__mqd_t;
typedef	__uint32_t	__uid_t;
typedef	unsigned int	__useconds_t;
typedef	int		__cpuwhich_t;
typedef	int		__cpulevel_t;
typedef int		__cpusetid_t;
typedef	int		__ct_rune_t;
typedef	__ct_rune_t	__rune_t;
typedef	__ct_rune_t	__wint_t;
typedef	__uint_least16_t __char16_t;
typedef	__uint_least32_t __char32_t;
typedef struct {
	long long __max_align1 ;
	long double __max_align2 ;
} __max_align_t;
typedef	__uint64_t	__dev_t;
typedef	__uint32_t	__fixpt_t;
typedef int _Mbstatet;
typedef _Mbstatet __mbstate_t;
typedef __uintmax_t     __rman_res_t;
typedef	__int8_t		int8_t;
typedef	__int16_t		int16_t;
typedef	__int32_t		int32_t;
typedef	__int64_t		int64_t;
typedef	__uint8_t		uint8_t;
typedef	__uint16_t		uint16_t;
typedef	__uint32_t		uint32_t;
typedef	__uint64_t		uint64_t;
typedef	__intptr_t		intptr_t;
typedef	__uintptr_t		uintptr_t;
typedef	__intmax_t		intmax_t;
typedef	__uintmax_t		uintmax_t;
typedef	__int_least8_t		int_least8_t;
typedef	__int_least16_t		int_least16_t;
typedef	__int_least32_t		int_least32_t;
typedef	__int_least64_t		int_least64_t;
typedef	__uint_least8_t		uint_least8_t;
typedef	__uint_least16_t	uint_least16_t;
typedef	__uint_least32_t	uint_least32_t;
typedef	__uint_least64_t	uint_least64_t;
typedef	__int_fast8_t		int_fast8_t;
typedef	__int_fast16_t		int_fast16_t;
typedef	__int_fast32_t		int_fast32_t;
typedef	__int_fast64_t		int_fast64_t;
typedef	__uint_fast8_t		uint_fast8_t;
typedef	__uint_fast16_t		uint_fast16_t;
typedef	__uint_fast32_t		uint_fast32_t;
typedef	__uint_fast64_t		uint_fast64_t;
extern void FAS_DisableInterrupts(void);
typedef struct {
    uint32_t *pc;
    uint32_t line;
} FAS_ASSERT_LOCATION_s;
extern void FAS_StoreAssertLocation(uint32_t *pc, uint32_t line);
static inline void FAS_InfiniteLoop(void) {
    FAS_DisableInterrupts();
    while (1) {
    }
}
typedef enum {
    STD_OK,
    STD_NOT_OK,
} STD_RETURN_TYPE_e;
typedef enum {
    STD_PIN_LOW,
    STD_PIN_HIGH,
    STD_PIN_UNDEFINED,
} STD_PIN_STATE_e;
_Static_assert(0 == 0, "false seems to have been modified.");
_Static_assert(1 != 0, "true seems to have been modified.");
_Static_assert(1 == 1, "true seems to have been modified.");
_Static_assert(STD_OK == 0, "STD_OK seems to have been modified.");
_Static_assert(STD_OK != STD_NOT_OK, "STD_OK or STD_NOT_OK seem to have been modified.");
_Static_assert(STD_NOT_OK == 1, "STD_NOT_OK seems to have been modified.");
typedef enum {
    BS_STRING_WITH_PRECHARGE,
    BS_STRING_WITHOUT_PRECHARGE,
} BS_STRING_PRECHARGE_PRESENT_e;
typedef enum {
    BS_STRING0    = 0u,
    BS_STRING1    = 1u,
    BS_STRING2    = 2u,
    BS_STRING_MAX = 3u,
} BS_STRING_ID_e;
_Static_assert(((1u) <= (uint8_t)0xff), "This code assumes BS_NR_OF_STRINGS fits into uint8_t");
extern BS_STRING_PRECHARGE_PRESENT_e bs_stringsWithPrecharge[(1u)];
 __inline int __isfinite(double d)
{ return (((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0; }
 __inline int __isfinitef(float f)
{ return (((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) == 0; }
 __inline int __isfinitel(long double e)
{ return (((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0; }
 __inline int __isnan(double d)
{ return (((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) &&
        ((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)) == 0); }
 __inline int __isnanf(float f)
{ return (((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) &&
        (((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)) == 0); }
 __inline int __isnanl(long double e)
{ return (((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) &&
        ((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)) == 0); }
 __inline int __isnormal(double d)
{ return (((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)) == 0) &&
         ((((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0); }
 __inline int __isnormalf(float f)
{ return ((((((unsigned int)((_ftoi(f)) >> (24-1))) & ((128u * 2) - 1)) == 0)) == 0) &&
         ((((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) == 0); }
 __inline int __isnormall(long double e)
{ return (((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)) == 0) &&
         ((((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) == 0); }
 __inline int __signbit(double d)
{ return (((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & ((__uint64_t)(1) << (64-1))) == 0)) == 0; }
 __inline int __signbitf(float f)
{ return ((((_ftoi(f)) & ((__uint32_t)(1) << (32-1))) == 0)) == 0; }
 __inline int __signbitl(long double e)
{ return (((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & ((__uint64_t)(1) << (64-1))) == 0)) == 0; }
 __inline int __isinff(float f)
{ return (((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)) && ((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)); }
 __inline int __isinf (double d)
{ return (((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) && (((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)); }
 __inline int __isinfl(long double e)
{ return (((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)) && (((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)); }
 __inline int __fpclassifyf(float f)
{
    if ((((((unsigned int)((_ftoi(f)) >> 16)) & 0x7f80u) == 0x7f80u)))
    {
        if (((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)))
            return 1;
        else return 2;
    }
    if ((((((unsigned int)((_ftoi(f)) >> (24-1))) & ((128u * 2) - 1)) == 0)))
    {
        if (((((_ftoi(f)) & (((__uint32_t)(1) << (24-1)) - 1)) == 0)))
            return 0;
        else return (-2);
    }
    return (-1);
}
 __inline int __fpclassify (double d)
{
    if ((((((unsigned int)(((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> 48)) & 0x7ff0u) == 0x7ff0u)))
    {
        if ((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
            return 1;
        else return 2;
    }
    if (((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)))
    {
        if ((((((((__uint64_t)_hi(d) << 32 | _lo(d)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
            return 0;
        else return (-2);
    }
    return (-1);
}
 __inline int __fpclassifyl(long double e)
{
    if ((((((unsigned int)(((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> 48)) & 0x7ff0u) == 0x7ff0u)))
    {
        if ((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
            return 1;
        else return 2;
    }
    if (((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) >> (53-1)) & ((1024u * 2) - 1)) == 0)))
    {
        if ((((((((__uint64_t)_hi(e) << 32 | _lo(e)))) & (((__uint64_t)(1) << (53-1)) - 1)) == 0)))
            return 0;
        else return (-2);
    }
    return (-1);
}
typedef	double	double_t;
typedef	float	float_t;
 double      acos(double x);
 float       acosf(float x);
 long double acosl(long double x);
 double      asin(double x);
 float       asinf(float x);
 long double asinl(long double x);
 double      atan(double x);
 float       atanf(float x);
 long double atanl(long double x);
 double      atan2(double y, double x);
 float       atan2f(float y, float x);
 long double atan2l(long double y, long double x);
 double      cos(double x);
 float       cosf(float x);
 long double cosl(long double x);
 double      sin(double x);
 float       sinf(float x);
 long double sinl(long double x);
 double      tan(double x);
 float       tanf(float x);
 long double tanl(long double x);
 double      acosh(double x);
 float       acoshf(float x);
 long double acoshl(long double x);
 double      asinh(double x);
 float       asinhf(float x);
 long double asinhl(long double x);
 double      atanh(double x);
 float       atanhf(float x);
 long double atanhl(long double x);
 double      cosh(double x);
 float       coshf(float x);
 long double coshl(long double x);
 double      sinh(double x);
 float       sinhf(float x);
 long double sinhl(long double x);
 double      tanh(double x);
 float       tanhf(float x);
 long double tanhl(long double x);
 double      exp(double x);
 float       expf(float x);
 long double expl(long double x);
 double      exp2(double x);
 float       exp2f(float x);
 long double exp2l(long double x);
 double      expm1(double x);
 float       expm1f(float x);
 long double expm1l(long double x);
 double      frexp(double val, int *e);
 float       frexpf(float val, int *e);
 long double frexpl(long double val, int *e);
 int         ilogb(double x);
 int         ilogbf(float x);
 int         ilogbl(long double x);
 double      ldexp(double x, int e);
 float       ldexpf(float x, int e);
 long double ldexpl(long double x, int e);
 double      log(double x);
 float       logf(float x);
 long double logl(long double x);
 double      log10(double x);
 float       log10f(float x);
 long double log10l(long double x);
 double      log1p(double x);
 float       log1pf(float x);
 long double log1pl(long double x);
 double      log2(double x);
 float       log2f(float x);
 long double log2l(long double x);
 double      logb(double x);
 float       logbf(float x);
 long double logbl(long double x);
 double      modf(double val, double *iptr);
 float       modff(float val, float *iptr);
 long double modfl(long double val, long double *iptr);
 double      scalbn(double x, int n);
 float       scalbnf(float x, int n);
 long double scalbnl(long double x, int n);
 double      scalbln(double x, long n);
 float       scalblnf(float x, long n);
 long double scalblnl(long double x, long n);
 double      cbrt(double x);
 float       cbrtf(float x);
 long double cbrtl(long double x);
 double      fabs(double x);
 float       fabsf(float x);
 long double fabsl(long double x);
 double      hypot(double x, double y);
 float       hypotf(float x, float y);
 long double hypotl(long double x, long double y);
 double      pow(double x, double y);
 float       powf(float x, float y);
 long double powl(long double x, long double y);
 double      sqrt(double x);
 float       sqrtf(float x);
 long double sqrtl(long double x);
 double      erf(double x);
 float       erff(float x);
 long double erfl(long double x);
 double      erfc(double x);
 float       erfcf(float x);
 long double erfcl(long double x);
 double      lgamma(double x);
 float       lgammaf(float x);
 long double lgammal(long double x);
 double      tgamma(double x);
 float       tgammaf(float x);
 long double tgammal(long double x);
 double      ceil(double x);
 float       ceilf(float x);
 long double ceill(long double x);
 double      floor(double x);
 float       floorf(float x);
 long double floorl(long double x);
 double      nearbyint(double x);
 float       nearbyintf(float x);
 long double nearbyintl(long double x);
 double      rint(double x);
 float       rintf(float x);
 long double rintl(long double x);
 long        lrint(double x);
 long        lrintf(float x);
 long        lrintl(long double x);
 long long   llrint(double x);
 long long   llrintf(float x);
 long long   llrintl(long double x);
 double      round(double x);
 float       roundf(float x);
 long double roundl(long double x);
 long        lround(double x);
 long        lroundf(float x);
 long        lroundl(long double x);
 long long   llround(double x);
 long long   llroundf(float x);
 long long   llroundl(long double x);
 double      trunc(double x);
 float       truncf(float x);
 long double truncl(long double x);
 double      fmod(double x, double y);
 float       fmodf(float x, float y);
 long double fmodl(long double x, long double y);
 double      remainder(double x, double y);
 float       remainderf(float x, float y);
 long double remainderl(long double x, long double y);
 double      remquo(double x, double y, int *quo);
 float       remquof(float x, float y, int *quo);
 long double remquol(long double x, long double y, int *quo);
 double      copysign(double x, double y);
 float       copysignf(float x, float y);
 long double copysignl(long double x, long double y);
 double      nan(const char *tagp);
 float       nanf(const char *tagp);
 long double nanl(const char *tagp);
 double      nextafter(double x, double y);
 float       nextafterf(float x, float y);
 long double nextafterl(long double x, long double y);
 double      nexttoward(double x, long double y);
 float       nexttowardf(float x, long double y);
 long double nexttowardl(long double x, long double y);
 double      fdim(double x, double y);
 float       fdimf(float x, float y);
 long double fdiml(long double x, long double y);
 double      fmax(double x, double y);
 float       fmaxf(float x, float y);
 long double fmaxl(long double x, long double y);
 double      fmin(double x, double y);
 float       fminf(float x, float y);
 long double fminl(long double x, long double y);
 double      fma(double x, double y, double z);
 float       fmaf(float x, float y, float z);
 long double fmal(long double x, long double y, long double z);
typedef uint16_t FRAM_PROJECT_ID;
typedef enum {
    FRAM_ACCESS_OK,
    FRAM_ACCESS_SPI_BUSY,
    FRAM_ACCESS_CRC_BUSY,
    FRAM_ACCESS_CRC_ERROR,
} FRAM_RETURN_TYPE_e;
typedef struct {
    void *blockptr;
    uint32_t datalength;
    uint32_t address;
} FRAM_BASE_HEADER_s;
typedef enum {
    FRAM_BLOCK_ID_VERSION,
    FRAM_BLOCK_ID_SOC,
    FRAM_BLOCK_ID_SBC_INIT_STATE,
    FRAM_BLOCK_ID_DEEP_DISCHARGE_FLAG,
    FRAM_BLOCK_ID_SOE,
    FRAM_BLOCK_ID_SYS_MON_RECORD,
    FRAM_BLOCK_ID_INSULATION_FLAG,
    FRAM_BLOCK_MAX,
} FRAM_BLOCK_ID_e;
typedef struct {
    FRAM_PROJECT_ID project;
    uint8_t major;
    uint8_t minor;
    uint8_t patch;
} FRAM_VERSION_s;
typedef struct {
    uint8_t phase;
    STD_RETURN_TYPE_e finState;
} FRAM_SBC_INIT_s;
typedef struct {
    float_t minimumSoc_perc[(1u)];
    float_t maximumSoc_perc[(1u)];
    float_t averageSoc_perc[(1u)];
} FRAM_SOC_s;
typedef struct {
    float_t minimumSoe_perc[(1u)];
    float_t maximumSoe_perc[(1u)];
    float_t averageSoe_perc[(1u)];
} FRAM_SOE_s;
typedef struct {
    _Bool deepDischargeFlag[(1u)];
} FRAM_DEEP_DISCHARGE_FLAG_s;
typedef struct {
    _Bool groundErrorDetected;
} FRAM_INSULATION_FLAG_s;
typedef struct {
    _Bool anyTimingIssueOccurred;
    uint32_t taskEngineViolatingDuration;
    uint32_t taskEngineEnterTimestamp;
    uint32_t task1msViolatingDuration;
    uint32_t task1msEnterTimestamp;
    uint32_t task10msViolatingDuration;
    uint32_t task10msEnterTimestamp;
    uint32_t task100msViolatingDuration;
    uint32_t task100msEnterTimestamp;
    uint32_t task100msAlgorithmViolatingDuration;
    uint32_t task100msAlgorithmEnterTimestamp;
} FRAM_SYS_MON_RECORD_s;
extern FRAM_BASE_HEADER_s fram_base_header[FRAM_BLOCK_MAX];
extern FRAM_VERSION_s fram_version;
extern FRAM_SOC_s fram_soc;
extern FRAM_SOE_s fram_soe;
extern FRAM_SBC_INIT_s fram_sbcInit;
extern FRAM_DEEP_DISCHARGE_FLAG_s fram_deepDischargeFlags;
extern FRAM_SYS_MON_RECORD_s fram_sys_mon_record;
extern FRAM_INSULATION_FLAG_s fram_insulationFlags;
typedef uint64_t uint64;
typedef uint32_t uint32;
typedef uint16_t uint16;
typedef uint8_t uint8;
typedef _Bool boolean;
typedef int64_t sint64;
typedef int32_t sint32;
typedef int16_t sint16;
typedef int8_t sint8;
typedef float float32;
typedef double float64;
typedef uint8 Std_ReturnType;
typedef struct
{
    uint16 vendorID;
    uint16 moduleID;
    uint8  instanceID;
    uint8  sw_major_version;
    uint8  sw_minor_version;
    uint8  sw_patch_version;
} Std_VersionInfoType;
  typedef unsigned char StatusType;
typedef boolean tBoolean;
typedef enum loopBackType
{
    Digital_Lbk = 0U,
    Analog_Lbk = 1U
}loopBackType_t;
typedef enum config_value_type
{
	InitialValue,
	CurrentValue
}config_value_type_t;
typedef volatile struct gioBase
{
    uint32 GCR0;
    uint32   rsvd;
    uint32 INTDET;
    uint32 POL;
    uint32 ENASET;
    uint32 ENACLR;
    uint32 LVLSET;
    uint32 LVLCLR;
    uint32 FLG;
    uint32 OFF1;
    uint32 OFF2;
    uint32 EMU1;
	uint32 EMU2;
} gioBASE_t;
typedef volatile struct gioPort
{
    uint32 DIR;
    uint32 DIN;
    uint32 DOUT;
    uint32 DSET;
    uint32 DCLR;
    uint32 PDR;
    uint32 PULDIS;
    uint32 PSL;
} gioPORT_t;
typedef volatile struct hetBase
{
    uint32 GCR;
    uint32 PFR;
    uint32 ADDR;
    uint32 OFF1;
    uint32 OFF2;
    uint32 INTENAS;
    uint32 INTENAC;
    uint32 EXC1;
    uint32 EXC2;
    uint32 PRY;
    uint32 FLG;
    uint32 AND;
    uint32   rsvd1;
    uint32 HRSH;
    uint32 XOR;
    uint32 REQENS;
    uint32 REQENC;
    uint32 REQDS;
    uint32   rsvd2;
    uint32 DIR;
    uint32 DIN;
    uint32 DOUT;
    uint32 DSET;
    uint32 DCLR;
    uint32 PDR;
    uint32 PULDIS;
    uint32 PSL;
    uint32   rsvd3;
    uint32   rsvd4;
    uint32 PCR;
    uint32 PAR;
    uint32 PPR;
    uint32 SFPRLD;
    uint32 SFENA;
    uint32   rsvd5;
    uint32 LBPSEL;
    uint32 LBPDIR;
    uint32 PINDIS;
} hetBASE_t;
typedef volatile struct hetInstructionBase
{
    uint32 Program;
    uint32 Control;
    uint32 Data;
    uint32   rsvd1;
} hetINSTRUCTION_t;
typedef volatile struct het1RamBase
{
    hetINSTRUCTION_t Instruction[160U];
} hetRAMBASE_t;
typedef unsigned size_t;
 size_t  strlen(const char *string);
 char *strcpy(char * __restrict dest,
                        const char * __restrict src);
 char *strncpy(char * __restrict dest,
                         const char * __restrict src, size_t n);
 char *strcat(char * __restrict string1,
                        const char * __restrict string2);
 char *strncat(char * __restrict dest,
                         const char * __restrict src, size_t n);
 char *strchr(const char *string, int c);
 char *strrchr(const char *string, int c);
 int  strcmp(const char *string1, const char *string2);
 int  strncmp(const char *string1, const char *string2, size_t n);
 int     strcoll(const char *string1, const char *_string2);
 size_t  strxfrm(char * __restrict to,
                             const char * __restrict from, size_t n);
 char   *strpbrk(const char *string, const char *chs);
 size_t  strspn(const char *string, const char *chs);
 size_t  strcspn(const char *string, const char *chs);
 char   *strstr(const char *string1, const char *string2);
 char   *strtok(char * __restrict str1,
                            const char * __restrict str2);
 char   *strerror(int _errno);
 char   *strdup(const char *string);
 void   *memmove(void *s1, const void *s2, size_t n);
 void   *memccpy(void *dest, const void *src, int ch, size_t count);
 void   *memcpy(void * __restrict s1,
                            const void * __restrict s2, size_t n);
 int     memcmp(const void *cs, const void *ct, size_t n);
 void   *memchr(const void *cs, int c, size_t n);
 void   *memset(void *mem, int ch, size_t length);
enum hetPinSelect
{
    PIN_HET_0 = 0U,
    PIN_HET_1 = 1U,
    PIN_HET_2 = 2U,
    PIN_HET_3 = 3U,
    PIN_HET_4 = 4U,
    PIN_HET_5 = 5U,
    PIN_HET_6 = 6U,
    PIN_HET_7 = 7U,
    PIN_HET_8 = 8U,
    PIN_HET_9 = 9U,
    PIN_HET_10 = 10U,
    PIN_HET_11 = 11U,
    PIN_HET_12 = 12U,
    PIN_HET_13 = 13U,
    PIN_HET_14 = 14U,
    PIN_HET_15 = 15U,
    PIN_HET_16 = 16U,
    PIN_HET_17 = 17U,
    PIN_HET_18 = 18U,
    PIN_HET_19 = 19U,
    PIN_HET_20 = 20U,
    PIN_HET_21 = 21U,
    PIN_HET_22 = 22U,
    PIN_HET_23 = 23U,
    PIN_HET_24 = 24U,
    PIN_HET_25 = 25U,
    PIN_HET_26 = 26U,
    PIN_HET_27 = 27U,
    PIN_HET_28 = 28U,
    PIN_HET_29 = 29U,
    PIN_HET_30 = 30U,
    PIN_HET_31 = 31U
};
typedef struct hetSignal
{
	uint32 duty;
	float64   period;
} hetSIGNAL_t;
typedef struct het_config_reg
{
    uint32 CONFIG_GCR;
    uint32 CONFIG_PFR;
    uint32 CONFIG_INTENAS;
    uint32 CONFIG_INTENAC;
    uint32 CONFIG_PRY;
    uint32 CONFIG_AND;
    uint32 CONFIG_HRSH;
    uint32 CONFIG_XOR;
    uint32 CONFIG_DIR;
    uint32 CONFIG_PDR;
	uint32 CONFIG_PULDIS;
	uint32 CONFIG_PSL;
	uint32 CONFIG_PCR;
} het_config_reg_t;
void hetInit(void);
void   pwmStart(hetRAMBASE_t * hetRAM,uint32 pwm);
void   pwmStop(hetRAMBASE_t * hetRAM,uint32 pwm);
void   pwmSetDuty(hetRAMBASE_t * hetRAM,uint32 pwm, uint32 pwmDuty);
void   pwmSetSignal(hetRAMBASE_t * hetRAM,uint32 pwm, hetSIGNAL_t signal);
void   pwmGetSignal(hetRAMBASE_t * hetRAM,uint32 pwm, hetSIGNAL_t *signal);
void   pwmEnableNotification(hetBASE_t * hetREG,uint32 pwm, uint32 notification);
void   pwmDisableNotification(hetBASE_t * hetREG,uint32 pwm, uint32 notification);
void   pwmNotification(hetBASE_t * hetREG,uint32 pwm, uint32 notification);
void   edgeResetCounter(hetRAMBASE_t * hetRAM,uint32 edge);
uint32 edgeGetCounter(hetRAMBASE_t * hetRAM,uint32 edge);
void   edgeEnableNotification(hetBASE_t * hetREG,uint32 edge);
void   edgeDisableNotification(hetBASE_t * hetREG,uint32 edge);
void   edgeNotification(hetBASE_t * hetREG,uint32 edge);
void capGetSignal(hetRAMBASE_t * hetRAM, uint32 cap, hetSIGNAL_t *signal);
void   hetResetTimestamp(hetRAMBASE_t * hetRAM);
uint32 hetGetTimestamp(hetRAMBASE_t * hetRAM);
void het1GetConfigValue(het_config_reg_t *config_reg, config_value_type_t type);
void het2GetConfigValue(het_config_reg_t *config_reg, config_value_type_t type);
void hetNotification(hetBASE_t *het, uint32 offset);
typedef volatile struct spiBase
{
    uint32  GCR0;
    uint32  GCR1;
    uint32  INT0;
    uint32  LVL;
    uint32  FLG;
    uint32  PC0;
    uint32  PC1;
    uint32  PC2;
    uint32  PC3;
    uint32  PC4;
    uint32  PC5;
    uint32  PC6;
    uint32  PC7;
    uint32  PC8;
    uint32  DAT0;
    uint32  DAT1;
    uint32  BUF;
    uint32  EMU;
    uint32  DELAY;
    uint32  DEF;
    uint32  FMT0;
    uint32  FMT1;
    uint32  FMT2;
    uint32  FMT3;
    uint32  INTVECT0;
    uint32  INTVECT1;
    uint32  RESERVED[51U];
    uint32  IOLPKTSTCR;
} spiBASE_t;
enum spiChipSelect
{
    SPI_CS_NONE = 0xFFU,
    SPI_CS_0    = 0xFEU,
    SPI_CS_1    = 0xFDU,
    SPI_CS_2    = 0xFBU,
    SPI_CS_3    = 0xF7U,
    SPI_CS_4    = 0xEFU,
    SPI_CS_5    = 0xDFU,
    SPI_CS_6    = 0xBFU,
    SPI_CS_7    = 0x7FU
};
enum spiPinSelect
{
    SPI_PIN_CS0    = 0U,
    SPI_PIN_CS1    = 1U,
    SPI_PIN_CS2    = 2U,
    SPI_PIN_CS3    = 3U,
    SPI_PIN_CS4    = 4U,
    SPI_PIN_CS5    = 5U,
    SPI_PIN_CS6    = 6U,
    SPI_PIN_CS7    = 7U,
    SPI_PIN_ENA    = 8U,
    SPI_PIN_CLK    = 9U,
    SPI_PIN_SIMO   = 10U,
    SPI_PIN_SOMI   = 11U,
    SPI_PIN_SIMO_1 = 17U,
    SPI_PIN_SIMO_2 = 18U,
    SPI_PIN_SIMO_3 = 19U,
    SPI_PIN_SIMO_4 = 20U,
    SPI_PIN_SIMO_5 = 21U,
    SPI_PIN_SIMO_6 = 22U,
    SPI_PIN_SIMO_7 = 23U,
    SPI_PIN_SOMI_1 = 25U,
    SPI_PIN_SOMI_2 = 26U,
    SPI_PIN_SOMI_3 = 27U,
    SPI_PIN_SOMI_4 = 28U,
    SPI_PIN_SOMI_5 = 29U,
    SPI_PIN_SOMI_6 = 30U,
    SPI_PIN_SOMI_7 = 31U
};
typedef enum dataformat
{
    SPI_FMT_0 = 0U,
    SPI_FMT_1 = 1U,
    SPI_FMT_2 = 2U,
    SPI_FMT_3 = 3U
}SPIDATAFMT_t;
typedef struct spiDAT1RegConfig
{
    boolean CS_HOLD;
    boolean WDEL;
    SPIDATAFMT_t DFSEL;
    uint8 CSNR;
}spiDAT1_t;
typedef enum SpiTxRxDataStatus
{
    SPI_READY = 0U,
    SPI_PENDING = 1U,
    SPI_COMPLETED = 2U
}SpiDataStatus_t;
typedef struct spi_config_reg
{
    uint32 CONFIG_GCR1;
    uint32 CONFIG_INT0;
    uint32 CONFIG_LVL;
    uint32 CONFIG_PC0;
    uint32 CONFIG_PC1;
    uint32 CONFIG_PC6;
    uint32 CONFIG_PC7;
    uint32 CONFIG_PC8;
    uint32 CONFIG_DELAY;
    uint32 CONFIG_FMT0;
    uint32 CONFIG_FMT1;
    uint32 CONFIG_FMT2;
    uint32 CONFIG_FMT3;
}spi_config_reg_t;
void spiInit(void);
void spiSetFunctional(spiBASE_t *spi, uint32 port);
void spiEnableNotification(spiBASE_t *spi, uint32 flags);
void spiDisableNotification(spiBASE_t *spi, uint32 flags);
uint32 spiTransmitData(spiBASE_t *spi, spiDAT1_t *dataconfig_t, uint32 blocksize, uint16 * srcbuff);
void spiSendData(spiBASE_t *spi, spiDAT1_t *dataconfig_t, uint32 blocksize, uint16 * srcbuff);
uint32 spiReceiveData(spiBASE_t *spi, spiDAT1_t *dataconfig_t, uint32 blocksize, uint16 * destbuff);
void spiGetData(spiBASE_t *spi, spiDAT1_t *dataconfig_t, uint32 blocksize, uint16 * destbuff);
uint32 spiTransmitAndReceiveData(spiBASE_t *spi, spiDAT1_t *dataconfig_t, uint32 blocksize, uint16 * srcbuff, uint16 * destbuff);
void spiSendAndGetData(spiBASE_t *spi, spiDAT1_t *dataconfig_t, uint32 blocksize, uint16 * srcbuff, uint16 * destbuff);
void spiEnableLoopback(spiBASE_t *spi, loopBackType_t Loopbacktype);
void spiDisableLoopback(spiBASE_t *spi);
SpiDataStatus_t SpiTxStatus(spiBASE_t *spi);
SpiDataStatus_t SpiRxStatus(spiBASE_t *spi);
void spi1GetConfigValue(spi_config_reg_t *config_reg, config_value_type_t type);
void spi2GetConfigValue(spi_config_reg_t *config_reg, config_value_type_t type);
void spi3GetConfigValue(spi_config_reg_t *config_reg, config_value_type_t type);
void spi4GetConfigValue(spi_config_reg_t *config_reg, config_value_type_t type);
void spi5GetConfigValue(spi_config_reg_t *config_reg, config_value_type_t type);
void spiNotification(spiBASE_t *spi, uint32 flags);
void spiEndNotification(spiBASE_t *spi);
typedef enum {
    SPI_IDLE,
    SPI_BUSY,
} SPI_BUSY_STATE_e;
typedef enum {
    SPI_CHIP_SELECT_HARDWARE,
    SPI_CHIP_SELECT_SOFTWARE,
    SPI_CHIP_SELECT_MAX,
} SPI_CHIP_SELECT_TYPE_e;
typedef struct {
    spiDAT1_t *pConfig;
    spiBASE_t *pNode;
    volatile uint32_t *pGioPort;
    uint32_t csPin;
    SPI_CHIP_SELECT_TYPE_e csType;
} SPI_INTERFACE_CONFIG_s;
extern SPI_INTERFACE_CONFIG_s spi_ltcInterface[(1u)];
extern SPI_INTERFACE_CONFIG_s spi_mxmInterface;
extern SPI_INTERFACE_CONFIG_s spi_nxp775InterfaceTx[(1u)];
extern SPI_INTERFACE_CONFIG_s spi_nxp775InterfaceRx[(1u)];
extern SPI_INTERFACE_CONFIG_s spi_framInterface;
extern SPI_INTERFACE_CONFIG_s spi_spsInterface;
extern SPI_INTERFACE_CONFIG_s spi_sbcMcuInterface;
extern SPI_BUSY_STATE_e spi_busyFlags[];
extern const uint8_t spi_nrBusyFlags;
extern void SPI_SpsInterfaceSwitchToHighSpeed(SPI_INTERFACE_CONFIG_s *pSpiSpsInterface);
extern void SPI_SpsInterfaceSwitchToLowSpeed(SPI_INTERFACE_CONFIG_s *pSpiSpsInterface);
extern void SPI_Initialize(void);
extern STD_RETURN_TYPE_e SPI_TransmitDummyByte(SPI_INTERFACE_CONFIG_s *pSpiInterface, uint32_t delay);
extern STD_RETURN_TYPE_e SPI_TransmitData(SPI_INTERFACE_CONFIG_s *pSpiInterface, uint16 *pTxBuff, uint32 frameLength);
extern STD_RETURN_TYPE_e SPI_TransmitReceiveData(
    SPI_INTERFACE_CONFIG_s *pSpiInterface,
    uint16 *pTxBuff,
    uint16 *pRxBuff,
    uint32 frameLength);
extern void SPI_FramTransmitReceiveData(
    SPI_INTERFACE_CONFIG_s *pSpiInterface,
    uint16 *pTxBuff,
    uint16 *pRxBuff,
    uint32 frameLength);
extern STD_RETURN_TYPE_e SPI_TransmitReceiveDataDma(
    SPI_INTERFACE_CONFIG_s *pSpiInterface,
    uint16_t *pTxBuff,
    uint16_t *pRxBuff,
    uint32_t frameLength);
extern STD_RETURN_TYPE_e SPI_SlaveSetReceiveDataDma(
    SPI_INTERFACE_CONFIG_s *pSpiInterface,
    uint16_t *pTxBuff,
    uint16_t *pRxBuff,
    uint32_t frameLength);
extern STD_RETURN_TYPE_e SPI_Lock(uint8_t spi);
extern void SPI_Unlock(uint8_t spi);
extern void SPI_SetFunctional(spiBASE_t *pNode, enum spiPinSelect bit, _Bool hardwareControlled);
extern void SPI_DmaSendLastByte(uint8_t spiIndex);
extern STD_RETURN_TYPE_e SPI_CheckInterfaceAvailable(spiBASE_t *pNode);
extern uint8_t SPI_GetSpiIndex(spiBASE_t *pNode);
typedef enum
{
    fs8xStatusOk    = 0U,
    fs8xStatusError = 1U
} fs8x_status_t;
typedef enum
{
    fs8xSPI = 0,
    fs8xI2C = 1
} fs8x_commType_t;
typedef enum {
    fs8xRegRead,
    fs8xRegWrite
} fs8x_command_type_t;
typedef struct
{
    _Bool isFailSafe;
    uint8_t registerAddress;
    fs8x_command_type_t commandType;
    uint16_t writeData;
} fs8x_tx_frame_t;
typedef struct
{
    uint8_t deviceStatus;
    uint16_t readData;
} fs8x_rx_frame_t;
typedef struct
{
    uint16_t watchdogSeed;
    fs8x_commType_t communicationMode;
    uint8_t i2cAddressOtp;
} fs8x_drv_data_t;
typedef enum
{
    fs8xBuck1 = 4,
    fs8xBuck2 = 3,
    fs8xBuck3 = 2,
    fs8xLdo1 = 1,
    fs8xLdo2 = 0,
    fs8xVBoost = 5,
    fs8xVPre = 6
} fs8x_reg_output_t;
typedef enum
{
    fs8xAmuxGnd = (0x0000U << 0x0000U),
    fs8xAmuxVddio = (0x0001U << 0x0000U),
    fs8xAmuxTempSensor = (0x0002U << 0x0000U),
    fs8xAmuxBandgapMain = (0x0003U << 0x0000U),
    fs8xAmuxBandgapFailSafe = (0x0004U << 0x0000U),
    fs8xAmuxVbuck1Volt = (0x0005U << 0x0000U),
    fs8xAmuxVbuck2Volt = (0x0006U << 0x0000U),
    fs8xAmuxVbuck3VoltDiv2_5 = (0x0007U << 0x0000U),
    fs8xAmuxVpreVoltDiv2_5 = (0x0008U << 0x0000U),
    fs8xAmuxVboostVoltDiv2_5 = (0x0009U << 0x0000U),
    fs8xAmuxVldo1VoltDiv2_5 = (0x000AU << 0x0000U),
    fs8xAmuxVldo2VoltDiv2_5 = (0x000BU << 0x0000U),
    fs8xAmuxVbosVoltDiv2_5 = (0x000CU << 0x0000U),
    fs8xAmuxVsup1VoltDiv7_5 = (0x000EU << 0x0000U),
    fs8xAmuxWake1VoltDiv7_5 = (0x000FU << 0x0000U),
    fs8xAmuxWake2VoltDiv7_5 = (0x0010U << 0x0000U),
    fs8xAmuxVana = (0x0011U << 0x0000U),
    fs8xAmuxVdig = (0x0012U << 0x0000U),
    fs8xAmuxVdigFs = (0x0013U << 0x0000U),
    fs8xAmuxPsync = (0x0014U << 0x0000U),
    fs8xAmuxVsup1VoltDiv14 = (0x0001U << 0x0005U) | (0x000EU << 0x0000U),
    fs8xAmuxWake1VoltDiv14 = (0x0001U << 0x0005U) | (0x000FU << 0x0000U),
    fs8xAmuxWake2VoltDiv14 = (0x0001U << 0x0005U) | (0x0010U << 0x0000U)
} fs8x_amux_selection_t;
fs8x_status_t FS8x_WD_ChangeSeed(SPI_INTERFACE_CONFIG_s* spiInterface, fs8x_drv_data_t* drvData, uint16_t wdSeed);
fs8x_status_t FS8x_WD_Refresh(SPI_INTERFACE_CONFIG_s* spiInterface, fs8x_drv_data_t* drvData);
fs8x_status_t FS8x_FS0B_Release(SPI_INTERFACE_CONFIG_s* spiInterface, fs8x_drv_data_t* drvData);
fs8x_status_t FS8x_SwitchAMUXchannel(SPI_INTERFACE_CONFIG_s* spiInterface, fs8x_drv_data_t* drvData,
        fs8x_amux_selection_t channelSelection);
fs8x_status_t FS8x_SetRegulatorState(SPI_INTERFACE_CONFIG_s* spiInterface, fs8x_drv_data_t* drvData,
        fs8x_reg_output_t vreg, _Bool enable);
fs8x_status_t FS8x_GetFaultErrorCounterValue(SPI_INTERFACE_CONFIG_s* spiInterface, fs8x_drv_data_t* drvData,
        uint8_t* faultErrorCounterValue);
extern fs8x_status_t MCU_SPI_TransferData(SPI_INTERFACE_CONFIG_s* pSpiInterface, uint8_t* txFrame,
                uint16_t frameLengthBytes, uint8_t* rxFrame);
fs8x_status_t FS8x_ReadRegister(SPI_INTERFACE_CONFIG_s* pSpiInterface, fs8x_drv_data_t* drvData, _Bool isFailSafe,
        uint8_t address, fs8x_rx_frame_t* rxData);
fs8x_status_t FS8x_WriteRegister(SPI_INTERFACE_CONFIG_s* pSpiInterface, fs8x_drv_data_t* drvData, _Bool isFailSafe,
        uint8_t address, uint16_t writeData);
fs8x_status_t FS8x_WriteRegisterInit(SPI_INTERFACE_CONFIG_s* pSpiInterface, fs8x_drv_data_t* drvData, uint8_t address,
        uint16_t writeData);
fs8x_status_t FS8x_UpdateRegister(SPI_INTERFACE_CONFIG_s* pSpiInterface, fs8x_drv_data_t* drvData, _Bool isFailSafe,
        uint8_t address, int16_t mask, uint16_t writeData);
typedef struct {
    uint16_t grl_flags;
    uint16_t iOvervoltageUndervoltageSafeReaction1;
    uint16_t iOvervoltageUndervoltageSafeReaction2;
    uint16_t iWatchdogConfiguration;
    uint16_t i_safe_inputs;
    uint16_t iFailSafeSateMachine;
    uint16_t i_svs;
    uint16_t watchdogWindow;
    uint16_t watchdogSeed;
    uint16_t watchdogAnswer;
    uint16_t overvoltageUndervoltageRegisterStatus;
    uint16_t releaseFs0bPin;
    uint16_t safeIos;
    uint16_t diag_safety;
    uint16_t intb_mask;
    uint16_t states;
} FS85_FS_REGISTER_s;
typedef struct {
    uint16_t flag;
    uint16_t mode;
    uint16_t registerControl1;
    uint16_t registerControl2;
    uint16_t analogMultiplexer;
    uint16_t clock;
    uint16_t int_mask1;
    uint16_t int_mask2;
    uint16_t flag1;
    uint16_t flag2;
    uint16_t vmon_regx;
    uint16_t lvb1_svs;
    uint16_t memory0;
    uint16_t memory1;
    uint16_t deviceId;
} FS85_MAIN_REGISTERS_s;
typedef enum {
    SBC_NORMAL_MODE,
    SBC_DEBUG_MODE,
} FS85_OPERATION_MODE_e;
typedef struct {
    _Bool finUsed;
    STD_RETURN_TYPE_e finState;
    volatile uint32_t *pGIOport;
    uint32_t pin;
} FS85_FIN_CONFIGURATION_s;
typedef struct {
    FRAM_BLOCK_ID_e entry;
    FRAM_SBC_INIT_s *data;
} FS85_NVRAM_INFO_s;
typedef struct {
    SPI_INTERFACE_CONFIG_s *pSpiInterface;
    fs8x_drv_data_t configValues;
    FS85_FIN_CONFIGURATION_s fin;
    FS85_MAIN_REGISTERS_s mainRegister;
    FS85_FS_REGISTER_s fsRegister;
    FS85_NVRAM_INFO_s nvram;
    FS85_OPERATION_MODE_e mode;
} FS85_STATE_s;
extern FS85_STATE_s fs85xx_mcuSupervisor;
extern STD_RETURN_TYPE_e FS85_InitializeFsPhase(FS85_STATE_s *pInstance);
extern STD_RETURN_TYPE_e FS85_InitializeNumberOfRequiredWatchdogRefreshes(
    FS85_STATE_s *pInstance,
    uint8_t *requiredWatchdogRefreshes);
extern STD_RETURN_TYPE_e FS85_CheckFaultErrorCounter(FS85_STATE_s *pInstance);
extern STD_RETURN_TYPE_e FS85_SafetyPathChecks(FS85_STATE_s *pInstance);
extern STD_RETURN_TYPE_e SBC_TriggerWatchdog(FS85_STATE_s *pInstance);
typedef struct gio_config_reg
{
    uint32 CONFIG_INTDET;
    uint32 CONFIG_POL;
    uint32 CONFIG_INTENASET;
    uint32 CONFIG_LVLSET;
	uint32 CONFIG_PORTADIR;
	uint32 CONFIG_PORTAPDR;
	uint32 CONFIG_PORTAPSL;
	uint32 CONFIG_PORTAPULDIS;
	uint32 CONFIG_PORTBDIR;
	uint32 CONFIG_PORTBPDR;
	uint32 CONFIG_PORTBPSL;
	uint32 CONFIG_PORTBPULDIS;
}gio_config_reg_t;
void gioInit(void);
void gioSetDirection(gioPORT_t *port, uint32 dir);
void gioSetBit(gioPORT_t *port, uint32 bit, uint32 value);
void gioSetPort(gioPORT_t *port, uint32 value);
uint32 gioGetBit(gioPORT_t *port, uint32 bit);
uint32 gioGetPort(gioPORT_t *port);
void gioToggleBit(gioPORT_t *port, uint32 bit);
void gioEnableNotification(gioPORT_t *port, uint32 bit);
void gioDisableNotification(gioPORT_t *port, uint32 bit);
void gioNotification(gioPORT_t *port, uint32 bit);
void gioGetConfigValue(gio_config_reg_t *config_reg, config_value_type_t type);
typedef volatile struct systemBase1
{
    uint32 SYSPC1;
    uint32 SYSPC2;
    uint32 SYSPC3;
    uint32 SYSPC4;
    uint32 SYSPC5;
    uint32 SYSPC6;
    uint32 SYSPC7;
    uint32 SYSPC8;
    uint32 SYSPC9;
    uint32 rsvd1;
    uint32 rsvd2;
    uint32 rsvd3;
    uint32 CSDIS;
    uint32 CSDISSET;
    uint32 CSDISCLR;
    uint32 CDDIS;
    uint32 CDDISSET;
    uint32 CDDISCLR;
    uint32 GHVSRC;
    uint32 VCLKASRC;
    uint32 RCLKSRC;
    uint32 CSVSTAT;
    uint32 MSTGCR;
    uint32 MINITGCR;
    uint32 MSINENA;
    uint32 MSTFAIL;
    uint32 MSTCGSTAT;
    uint32 MINISTAT;
    uint32 PLLCTL1;
    uint32 PLLCTL2;
    uint32 SYSPC10;
    uint32 DIEIDL;
    uint32 DIEIDH;
    uint32 rsvd4;
    uint32 LPOMONCTL;
    uint32 CLKTEST;
    uint32 DFTCTRLREG1;
    uint32 DFTCTRLREG2;
    uint32 rsvd5;
    uint32 rsvd6;
    uint32 GPREG1;
    uint32 rsvd7;
    uint32 rsvd8;
    uint32 rsvd9;
    uint32 SSIR1;
    uint32 SSIR2;
    uint32 SSIR3;
    uint32 SSIR4;
    uint32 RAMGCR;
    uint32 BMMCR1;
    uint32 rsvd10;
    uint32 CPURSTCR;
    uint32 CLKCNTL;
    uint32 ECPCNTL;
    uint32 rsvd11;
    uint32 DEVCR1;
    uint32 SYSECR;
    uint32 SYSESR;
    uint32 SYSTASR;
    uint32 GBLSTAT;
    uint32 DEVID;
    uint32 SSIVEC;
    uint32 SSIF;
} systemBASE1_t;
typedef volatile struct systemBase2
{
    uint32 PLLCTL3;
    uint32 rsvd1;
    uint32 STCCLKDIV;
    uint32 rsvd2[6U];
    uint32 ECPCNTL;
    uint32 ECPCNTL1;
    uint32 rsvd3[4U];
    uint32 CLK2CNTRL;
    uint32 VCLKACON1;
    uint32 rsvd4[4U];
    uint32 HCLKCNTL;
    uint32 rsvd5[6U];
    uint32 CLKSLIP;
    uint32 rsvd6;
	uint32 IP1ECCERREN;
	uint32 rsvd7[28U];
    uint32 EFC_CTLEN;
    uint32 DIEIDL_REG0;
    uint32 DIEIDH_REG1;
    uint32 DIEIDL_REG2;
    uint32 DIEIDH_REG3;
} systemBASE2_t;
typedef volatile struct flashWBase
{
    uint32 FRDCNTL;
    uint32 rsvd1;
    uint32 EE_FEDACCTRL1;
    uint32 rsvd2;
    uint32 rsvd3;
    uint32 FEDAC_PASTATUS;
    uint32 FEDAC_PBSTATUS;
    uint32 FEDAC_GBLSTATUS;
    uint32 rsvd4;
    uint32 FEDACSDIS;
    uint32 FPRIM_ADD_TAG;
    uint32 FDUP_ADD_TAG;
    uint32 FBPROT;
    uint32 FBSE;
    uint32 FBBUSY;
    uint32 FBAC;
    uint32 FBPWRMODE;
    uint32 FBPRDY;
    uint32 FPAC1;
    uint32 rsvd5;
    uint32 FMAC;
    uint32 FMSTAT;
    uint32 FEMU_DMSW;
    uint32 FEMU_DLSW;
    uint32 FEMU_ECC;
    uint32 FLOCK;
    uint32 rsvd6;
    uint32 FDIAGCTRL;
    uint32 rsvd7;
    uint32 FRAW_ADDR;
    uint32 rsvd8;
    uint32 FPAR_OVR;
    uint32 rsvd9[13U];
    uint32 RCR_VALID;
    uint32 ACC_THRESHOLD;
    uint32 rsvd10;
    uint32 FEDACSDIS2;
    uint32 rsvd11;
    uint32 rsvd12;
    uint32 rsvd13;
    uint32 RCR_VALUE0;
    uint32 RCR_VALUE1;
    uint32 rsvd14[108U];
    uint32 FSM_WR_ENA;
    uint32 rsvd15[11U];
    uint32 EEPROM_CONFIG;
    uint32 rsvd16;
    uint32 FSM_SECTOR1;
    uint32 FSM_SECTOR2;
    uint32 rsvd17[78U];
    uint32 FCFG_BANK;
} flashWBASE_t;
typedef volatile struct l2ramwBase
{
    uint32 RAMCTRL;
    uint32 rsvd1[3];
    uint32 RAMERRSTATUS;
    uint32 rsvd2[4];
    uint32 DIAGDATAVECTOR_H;
    uint32 DIAGDATAVECTOR_L;
    uint32 DIAG_ECC;
    uint32 RAMTEST;
    uint32 rsvd3;
    uint32 RAMADDRDECVECT;
    uint32 MEMINITDOMAIN;
    uint32 rsvd4;
    uint32 BANKDOMAINMAP0;
    uint32 BANKDOMAINMAP1;
} l2ramwBASE_t;
typedef volatile struct ccmr5Base
{
    uint32 CCMSR1;
    uint32 CCMKEYR1;
    uint32 CCMSR2;
    uint32 CCMKEYR2;
    uint32 CCMSR3;
    uint32 CCMKEYR3;
    uint32 CCMPOLCNTRL;
    uint32 CCMSR4;
    uint32 CCMKEYR4;
    uint32 CCMPDSTAT0;
} ccmr5BASE_t;
void _coreInitRegisters_(void);
void _coreInitStackPointer_(void);
uint32 _getCPSRValue_(void);
void _checkMemInitOn_(void);
void _gotoCPUIdle_(void);
void _coreEnableIrqVicOffset_(void);
void _coreEnableVfp_(void);
void _coreEnableEventBusExport_(void);
void _coreDisableEventBusExport_(void);
uint32 _coreGetDataFault_(void);
void _coreClearDataFault_(void);
uint32 _coreGetInstructionFault_(void);
void _coreClearInstructionFault_(void);
uint32 _coreGetDataFaultAddress_(void);
void _coreClearDataFaultAddress_(void);
uint32 _coreGetInstructionFaultAddress_(void);
void _coreClearInstructionFaultAddress_(void);
uint32 _coreGetAuxiliaryDataFault_(void);
void _coreClearAuxiliaryDataFault_(void);
uint32 _coreGetAuxiliaryInstructionFault_(void);
void _coreClearAuxiliaryInstructionFault_(void);
void _disable_IRQ_interrupt_(void);
void _enable_IRQ_interrupt_(void);
void _enable_interrupt_(void);
void _esmCcmErrorsClear_(void);
void _memInit_(void);
void _cacheEnable_(void);
void _cacheDisable_(void);
void _dCacheInvalidate_(void);
void _iCacheInvalidate_(void);
enum systemClockSource
{
    SYS_OSC             = 0x0U,
    SYS_PLL1            = 0x1U,
    SYS_EXTERNAL1       = 0x3U,
    SYS_LPO_LOW         = 0x4U,
    SYS_LPO_HIGH        = 0x5U,
    SYS_PLL2            = 0x6U,
    SYS_EXTERNAL2       = 0x7U,
    SYS_VCLK            = 0x9U,
    SYS_PLL2_ODCLK_8    = 0xEU,
    SYS_PLL2_ODCLK_16   = 0xFU
};
typedef enum
{
    POWERON_RESET       = 0x8000U,
    OSC_FAILURE_RESET   = 0x4000U,
    WATCHDOG_RESET      = 0x2000U,
    WATCHDOG2_RESET     = 0x1000U,
    DEBUG_RESET         = 0x0800U,
    INTERCONNECT_RESET  = 0x0080U,
    CPU0_RESET          = 0x0020U,
    SW_RESET            = 0x0010U,
    EXT_RESET           = 0x0008U,
    NO_RESET            = 0x0000U
}resetSource_t;
typedef struct system_config_reg
{
    uint32 CONFIG_SYSPC1;
    uint32 CONFIG_SYSPC2;
    uint32 CONFIG_SYSPC7;
    uint32 CONFIG_SYSPC8;
    uint32 CONFIG_SYSPC9;
    uint32 CONFIG_CSDIS;
    uint32 CONFIG_CDDIS;
    uint32 CONFIG_GHVSRC;
    uint32 CONFIG_VCLKASRC;
    uint32 CONFIG_RCLKSRC;
    uint32 CONFIG_MSTGCR;
    uint32 CONFIG_MINITGCR;
    uint32 CONFIG_MSINENA;
    uint32 CONFIG_PLLCTL1;
    uint32 CONFIG_PLLCTL2;
    uint32 CONFIG_SYSPC10;
    uint32 CONFIG_LPOMONCTL;
    uint32 CONFIG_CLKTEST;
    uint32 CONFIG_DFTCTRLREG1;
    uint32 CONFIG_DFTCTRLREG2;
    uint32 CONFIG_GPREG1;
    uint32 CONFIG_RAMGCR;
    uint32 CONFIG_BMMCR1;
    uint32 CONFIG_CLKCNTL;
    uint32 CONFIG_ECPCNTL;
    uint32 CONFIG_DEVCR1;
    uint32 CONFIG_SYSECR;
    uint32 CONFIG_PLLCTL3;
    uint32 CONFIG_STCCLKDIV;
	uint32 CONFIG_ECPCNTL1;
    uint32 CONFIG_CLK2CNTRL;
    uint32 CONFIG_VCLKACON1;
	uint32 CONFIG_HCLKCNTL;
    uint32 CONFIG_CLKSLIP;
    uint32 CONFIG_EFC_CTLEN;
} system_config_reg_t;
void systemGetConfigValue(system_config_reg_t *config_reg, config_value_type_t type);
enum flashWPowerModes
{
    SYS_SLEEP   = 0U,
    SYS_STANDBY = 1U,
    SYS_ACTIVE  = 3U
};
void setupPLL(void);
void trimLPO(void);
void customTrimLPO(void);
void setupFlash(void);
void periphInit(void);
void mapClocks(void);
void systemInit(void);
void systemPowerDown(uint32 mode);
resetSource_t getResetSource(void);
extern void MCU_Delay_us(uint32_t delay_us);
extern uint32_t MCU_GetFreeRunningCount(void);
extern uint32_t MCU_ConvertFrcDifferenceToTimespan_us(uint32_t count);
extern _Bool MCU_IsTimeElapsed(uint32_t startCounter, uint32_t timeout_us);
typedef struct {
    void *pDatabaseEntry;
    uint32_t dataLength;
} DATA_BASE_s;
typedef enum {
    DATA_BLOCK_ID_CELL_VOLTAGE,
    DATA_BLOCK_ID_CELL_TEMPERATURE,
    DATA_BLOCK_ID_MIN_MAX,
    DATA_BLOCK_ID_CURRENT_SENSOR,
    DATA_BLOCK_ID_BALANCING_CONTROL,
    DATA_BLOCK_ID_SLAVE_CONTROL,
    DATA_BLOCK_ID_BALANCING_FEEDBACK_BASE,
    DATA_BLOCK_ID_USER_MUX,
    DATA_BLOCK_ID_OPEN_WIRE_BASE,
    DATA_BLOCK_ID_ALL_GPIO_VOLTAGES_BASE,
    DATA_BLOCK_ID_ERROR_STATE,
    DATA_BLOCK_ID_CONTACTOR_FEEDBACK,
    DATA_BLOCK_ID_INTERLOCK_FEEDBACK,
    DATA_BLOCK_ID_SOF,
    DATA_BLOCK_ID_SYSTEM_STATE,
    DATA_BLOCK_ID_MSL_FLAG,
    DATA_BLOCK_ID_RSL_FLAG,
    DATA_BLOCK_ID_MOL_FLAG,
    DATA_BLOCK_ID_SOX,
    DATA_BLOCK_ID_STATE_REQUEST,
    DATA_BLOCK_ID_MOVING_AVERAGE,
    DATA_BLOCK_ID_CELL_VOLTAGE_BASE,
    DATA_BLOCK_ID_CELL_TEMPERATURE_BASE,
    DATA_BLOCK_ID_CELL_VOLTAGE_REDUNDANCY0,
    DATA_BLOCK_ID_CELL_TEMPERATURE_REDUNDANCY0,
    DATA_BLOCK_ID_BALANCING_FEEDBACK_REDUNDANCY0,
    DATA_BLOCK_ID_ALL_GPIO_VOLTAGES_REDUNDANCY0,
    DATA_BLOCK_ID_OPEN_WIRE_REDUNDANCY0,
    DATA_BLOCK_ID_INSULATION_MONITORING,
    DATA_BLOCK_ID_PACK_VALUES,
    DATA_BLOCK_ID_HTSEN,
    DATA_BLOCK_ID_ADC_VOLTAGE,
    DATA_BLOCK_ID_DUMMY_FOR_SELF_TEST,
    DATA_BLOCK_ID_MAX,
} DATA_BLOCK_ID_e;
_Static_assert((int16_t)DATA_BLOCK_ID_MAX < 0xff, "Maximum number of database entries exceeds UINT8_MAX; adapted length " "checking in DATA_Initialize and DATA_IterateOverDatabaseEntries");
typedef struct {
    DATA_BLOCK_ID_e uniqueId;
    uint32_t timestamp;
    uint32_t previousTimestamp;
} DATA_BLOCK_HEADER_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t state;
    int32_t packVoltage_mV[(1u)];
    int16_t cellVoltage_mV[(1u)][((3u) * (16u))];
    uint64_t
        invalidCellVoltage[(1u)]
                          [(3u)];
    uint16_t nrValidCellVoltages[(1u)];
    uint32_t moduleVoltage_mV[(1u)][(3u)];
    _Bool validModuleVoltage[(1u)][(3u)];
} DATA_BLOCK_CELL_VOLTAGE_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t state;
    int16_t cellTemperature_ddegC[(1u)][((3u) * (8u))];
    uint16_t invalidCellTemperature
        [(1u)][(3u)];
    uint16_t nrValidTemperatures[(1u)];
} DATA_BLOCK_CELL_TEMPERATURE_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    int16_t averageCellVoltage_mV[(1u)];
    int16_t minimumCellVoltage_mV[(1u)];
    int16_t previousMinimumCellVoltage_mV[(1u)];
    int16_t maximumCellVoltage_mV[(1u)];
    int16_t previousMaximumCellVoltage_mV[(1u)];
    uint16_t nrModuleMinimumCellVoltage[(1u)];
    uint16_t nrCellMinimumCellVoltage[(1u)];
    uint16_t nrModuleMaximumCellVoltage[(1u)];
    uint16_t nrCellMaximumCellVoltage[(1u)];
    uint16_t validMeasuredCellVoltages[(1u)];
    float_t averageTemperature_ddegC[(1u)];
    int16_t minimumTemperature_ddegC[(1u)];
    uint16_t nrModuleMinimumTemperature[(1u)];
    uint16_t nrSensorMinimumTemperature[(1u)];
    int16_t maximumTemperature_ddegC[(1u)];
    uint16_t nrModuleMaximumTemperature[(1u)];
    uint16_t nrSensorMaximumTemperature[(1u)];
    uint16_t validMeasuredCellTemperatures[(1u)];
    uint8_t state;
} DATA_BLOCK_MIN_MAX_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    int32_t packCurrent_mA;
    uint8_t invalidPackCurrent;
    int32_t batteryVoltage_mV;
    uint8_t invalidBatteryVoltage;
    int32_t
        highVoltageBusVoltage_mV;
    uint8_t invalidHvBusVoltage;
    int32_t packPower_W;
    uint8_t invalidPackPower;
    int32_t stringVoltage_mV[(1u)];
    uint8_t invalidStringVoltage[(1u)];
    int32_t stringCurrent_mA[(1u)];
    uint8_t invalidStringCurrent[(1u)];
    int32_t stringPower_W[(1u)];
    uint8_t invalidStringPower[(1u)];
} DATA_BLOCK_PACK_VALUES_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    int32_t current_mA[(1u)];
    uint8_t invalidCurrentMeasurement[(1u)];
    uint8_t newCurrent;
    uint32_t previousTimestampCurrent[(1u)];
    uint32_t timestampCurrent[(1u)];
    int32_t sensorTemperature_ddegC[(1u)];
    uint8_t invalidSensorTemperatureMeasurement[(1u)];
    int32_t power_W[(1u)];
    uint8_t invalidPowerMeasurement[(1u)];
    uint8_t newPower;
    uint32_t previousTimestampPower[(1u)];
    uint32_t timestampPower[(1u)];
    int32_t currentCounter_As[(1u)];
    uint8_t invalidCurrentCountingMeasurement[(1u)];
    uint32_t previousTimestampCurrentCounting[(1u)];
    uint32_t timestampCurrentCounting[(1u)];
    int32_t energyCounter_Wh[(1u)];
    uint8_t invalidEnergyCountingMeasurement[(1u)];
    uint32_t previousTimestampEnergyCounting[(1u)];
    uint32_t timestampEnergyCounting[(1u)];
    uint8_t invalidHighVoltageMeasurement
        [(1u)][(3u)];
    int32_t highVoltage_mV[(1u)][(3u)];
    uint32_t previousTimestampHighVoltage
        [(1u)]
        [(3u)];
    uint32_t timestampHighVoltage[(1u)]
                                 [(3u)];
} DATA_BLOCK_CURRENT_SENSOR_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t enableBalancing;
    uint8_t threshold_mV;
    uint8_t request;
    uint8_t balancingState[(1u)]
                          [((3u) * (16u))];
    uint32_t deltaCharge_mAs[(1u)]
                            [((3u) * (16u))];
    uint16_t nrBalancedCells[(1u)];
} DATA_BLOCK_BALANCING_CONTROL_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t state;
    uint32_t eepromReadAddressToUse;
    uint32_t eepromReadAddressLastUsed;
    uint32_t eepromWriteAddressToUse;
    uint32_t eepromWriteAddressLastUsed;
    uint8_t ioValueOut[(3u)];
    uint8_t ioValueIn[(3u)];
    uint8_t eepromValueWrite[(3u)];
    uint8_t eepromValueRead[(3u)];
    uint8_t
        externalTemperatureSensor[(3u)];
} DATA_BLOCK_SLAVE_CONTROL_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t state;
    uint16_t value[(1u)][(3u)];
} DATA_BLOCK_BALANCING_FEEDBACK_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t state;
    uint16_t value[(1u)][8u * 2u * (3u)];
} DATA_BLOCK_USER_MUX_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t state;
    uint16_t nrOpenWires[(1u)];
    uint8_t openWire[(1u)]
                    [(3u) *
                     ((16u) + 1u)];
} DATA_BLOCK_OPEN_WIRE_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t state;
    int16_t gpioVoltages_mV[(1u)][(3u) * (10u)];
    int16_t gpaVoltages_mV[(1u)][(3u) * (2u)];
    uint16_t
        invalidGpioVoltages[(1u)]
                           [(3u)];
} DATA_BLOCK_ALL_GPIO_VOLTAGES_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    _Bool afeCommunicationCrcError[(1u)];
    _Bool afeSlaveMultiplexerError[(1u)];
    _Bool afeCommunicationSpiError[(1u)];
    _Bool afeConfigurationError[(1u)];
    _Bool afeCellVoltageInvalidError[(1u)];
    _Bool afeCellTemperatureInvalidError[(1u)];
    _Bool baseCellVoltageMeasurementTimeoutError;
    _Bool redundancy0CellVoltageMeasurementTimeoutError;
    _Bool baseCellTemperatureMeasurementTimeoutError;
    _Bool redundancy0CellTemperatureMeasurementTimeoutError;
    _Bool currentMeasurementTimeoutError[(1u)];
    _Bool currentMeasurementInvalidError[(1u)];
    _Bool currentSensorVoltage1TimeoutError[(1u)];
    _Bool currentSensorVoltage2TimeoutError[(1u)];
    _Bool currentSensorVoltage3TimeoutError[(1u)];
    _Bool currentSensorPowerTimeoutError[(1u)];
    _Bool currentSensorCoulombCounterTimeoutError[(1u)];
    _Bool currentSensorEnergyCounterTimeoutError[(1u)];
    _Bool powerMeasurementInvalidError[(1u)];
    _Bool mainFuseError;
    _Bool stringFuseError[(1u)];
    _Bool openWireDetectedError[(1u)];
    _Bool stateRequestTimingViolationError;
    _Bool canRxQueueFullError;
    _Bool coinCellLowVoltageError;
    _Bool plausibilityCheckPackVoltageError[(1u)];
    _Bool plausibilityCheckCellVoltageError[(1u)];
    _Bool plausibilityCheckCellVoltageSpreadError[(1u)];
    _Bool plausibilityCheckCellTemperatureError[(1u)];
    _Bool plausibilityCheckCellTemperatureSpreadError[(1u)];
    _Bool currentSensorNotRespondingError[(1u)];
    _Bool contactorInNegativePathOfStringFeedbackError[(1u)];
    _Bool contactorInPositivePathOfStringFeedbackError[(1u)];
    _Bool prechargeContactorFeedbackError[(1u)];
    _Bool interlockOpenedError;
    _Bool insulationMeasurementInvalidError;
    _Bool criticalLowInsulationResistanceError;
    _Bool warnableLowInsulationResistanceError;
    _Bool
        insulationGroundFaultDetectedError;
    _Bool prechargeAbortedDueToVoltage[(1u)];
    _Bool prechargeAbortedDueToCurrent[(1u)];
    _Bool deepDischargeDetectedError[(1u)];
    _Bool currentOnOpenStringDetectedError[(1u)];
    _Bool mcuDieTemperatureViolationError;
    _Bool mcuSbcFinError;
    _Bool mcuSbcRstbError;
    _Bool pexI2cCommunicationError;
    _Bool i2cRtcError;
    _Bool framReadCrcError;
    _Bool rtcClockIntegrityError;
    _Bool rtcBatteryLowError;
    _Bool taskEngineTimingViolationError;
    _Bool task1msTimingViolationError;
    _Bool task10msTimingViolationError;
    _Bool task100msTimingViolationError;
    _Bool task100msAlgoTimingViolationError;
    _Bool alertFlagSetError;
} DATA_BLOCK_ERROR_STATE_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint32_t contactorFeedback;
} DATA_BLOCK_CONTACTOR_FEEDBACK_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t interlockFeedback_IL_STATE;
    float_t interlockVoltageFeedback_IL_HS_VS_mV;
    float_t interlockVoltageFeedback_IL_LS_VS_mV;
    float_t interlockCurrentFeedback_IL_HS_CS_mA;
    float_t interlockCurrentFeedback_IL_LS_CS_mA;
} DATA_BLOCK_INTERLOCK_FEEDBACK_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    float_t recommendedContinuousPackChargeCurrent_mA;
    float_t
        recommendedContinuousPackDischargeCurrent_mA;
    float_t recommendedPeakPackChargeCurrent_mA;
    float_t recommendedPeakPackDischargeCurrent_mA;
    float_t recommendedContinuousChargeCurrent_mA
        [(1u)];
    float_t recommendedContinuousDischargeCurrent_mA
        [(1u)];
    float_t recommendedPeakChargeCurrent_mA[(1u)];
    float_t recommendedPeakDischargeCurrent_mA[(1u)];
} DATA_BLOCK_SOF_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    int32_t bmsCanState;
} DATA_BLOCK_SYSTEM_STATE_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t packChargeOvercurrent;
    uint8_t packDischargeOvercurrent;
    uint8_t overVoltage[(1u)];
    uint8_t underVoltage[(1u)];
    uint8_t overtemperatureCharge[(1u)];
    uint8_t overtemperatureDischarge[(1u)];
    uint8_t undertemperatureCharge[(1u)];
    uint8_t undertemperatureDischarge[(1u)];
    uint8_t cellChargeOvercurrent[(1u)];
    uint8_t stringChargeOvercurrent[(1u)];
    uint8_t cellDischargeOvercurrent[(1u)];
    uint8_t stringDischargeOvercurrent[(1u)];
    uint8_t pcbOvertemperature[(1u)];
    uint8_t pcbUndertemperature[(1u)];
} DATA_BLOCK_MSL_FLAG_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t overVoltage[(1u)];
    uint8_t underVoltage[(1u)];
    uint8_t overtemperatureCharge[(1u)];
    uint8_t overtemperatureDischarge[(1u)];
    uint8_t undertemperatureCharge[(1u)];
    uint8_t undertemperatureDischarge[(1u)];
    uint8_t cellChargeOvercurrent[(1u)];
    uint8_t stringChargeOvercurrent[(1u)];
    uint8_t cellDischargeOvercurrent[(1u)];
    uint8_t stringDischargeOvercurrent[(1u)];
    uint8_t pcbOvertemperature[(1u)];
    uint8_t pcbUndertemperature[(1u)];
} DATA_BLOCK_RSL_FLAG_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t overVoltage[(1u)];
    uint8_t underVoltage[(1u)];
    uint8_t overtemperatureCharge[(1u)];
    uint8_t overtemperatureDischarge[(1u)];
    uint8_t undertemperatureCharge[(1u)];
    uint8_t undertemperatureDischarge[(1u)];
    uint8_t cellChargeOvercurrent[(1u)];
    uint8_t stringChargeOvercurrent[(1u)];
    uint8_t cellDischargeOvercurrent[(1u)];
    uint8_t stringDischargeOvercurrent[(1u)];
    uint8_t pcbOvertemperature[(1u)];
    uint8_t pcbUndertemperature[(1u)];
} DATA_BLOCK_MOL_FLAG_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    float_t averageSoc_perc[(1u)];
    float_t minimumSoc_perc[(1u)];
    float_t maximumSoc_perc[(1u)];
    float_t averageSoe_perc[(1u)];
    float_t minimumSoe_perc[(1u)];
    float_t maximumSoe_perc[(1u)];
    float_t averageSoh_perc[(1u)];
    float_t minimumSoh_perc[(1u)];
    float_t maximumSoh_perc[(1u)];
    uint32_t maximumSoe_Wh[(1u)];
    uint32_t averageSoe_Wh[(1u)];
    uint32_t minimumSoe_Wh[(1u)];
} DATA_BLOCK_SOX_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t stateRequestViaCan;
    uint8_t previousStateRequestViaCan;
    uint8_t stateRequestViaCanPending;
    uint8_t stateCounter;
} DATA_BLOCK_STATE_REQUEST_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    float_t movingAverageCurrent1sInterval_mA;
    float_t movingAverageCurrent5sInterval_mA;
    float_t movingAverageCurrent10sInterval_mA;
    float_t movingAverageCurrent30sInterval_mA;
    float_t movingAverageCurrent60sInterval_mA;
    float_t movingAverageCurrentConfigurableInterval_mA;
    float_t movingAveragePower1sInterval_mA;
    float_t movingAveragePower5sInterval_mA;
    float_t movingAveragePower10sInterval_mA;
    float_t movingAveragePower30sInterval_mA;
    float_t movingAveragePower60sInterval_mA;
    float_t movingAveragePowerConfigurableInterval_mA;
} DATA_BLOCK_MOVING_AVERAGE_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    _Bool isImdRunning;
    _Bool isInsulationMeasurementValid;
    uint32_t insulationResistance_kOhm;
    _Bool
        areDeviceFlagsValid;
    _Bool
        dfIsCriticalResistanceDetected;
    _Bool dfIsWarnableResistanceDetected;
    _Bool dfIsChassisFaultDetected;
    _Bool dfIsChassisShortToHvPlus;
    _Bool dfIsChassisShortToHvMinus;
    _Bool dfIsDeviceErrorDetected;
    _Bool dfIsMeasurementUpToDate;
} DATA_BLOCK_INSULATION_MONITORING_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    int16_t temperature_ddegC;
    uint8_t humidity_perc;
} DATA_BLOCK_HTSEN_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    float_t adc1ConvertedVoltages_mV[(32u)];
} DATA_BLOCK_ADC_VOLTAGE_s;
typedef struct {
    DATA_BLOCK_HEADER_s header;
    uint8_t member1;
    uint8_t member2;
} DATA_BLOCK_DUMMY_FOR_SELF_TEST_s;
extern DATA_BASE_s data_database[DATA_BLOCK_ID_MAX];
typedef struct {
    DATA_BLOCK_ERROR_STATE_s *pTableError;
    DATA_BLOCK_MOL_FLAG_s *pTableMol;
    DATA_BLOCK_RSL_FLAG_s *pTableRsl;
    DATA_BLOCK_MSL_FLAG_s *pTableMsl;
} DIAG_DATABASE_SHIM_s;
extern const DIAG_DATABASE_SHIM_s diag_kDatabaseShim;
typedef enum {
    DIAG_ID_FLASHCHECKSUM,
    DIAG_ID_SYSTEM_MONITORING,
    DIAG_ID_CONFIGASSERT,
    DIAG_ID_AFE_SPI,
    DIAG_ID_AFE_COM_INTEGRITY,
    DIAG_ID_AFE_MUX,
    DIAG_ID_AFE_CONFIG,
    DIAG_ID_CAN_TIMING,
    DIAG_ID_CAN_RX_QUEUE_FULL,
    DIAG_ID_CAN_CC_RESPONDING,
    DIAG_ID_CAN_EC_RESPONDING,
    DIAG_ID_CURRENT_SENSOR_RESPONDING,
    DIAG_ID_PLAUSIBILITY_CELL_VOLTAGE,
    DIAG_ID_AFE_CELL_VOLTAGE_MEAS_ERROR,
    DIAG_ID_AFE_CELL_TEMPERATURE_MEAS_ERROR,
    DIAG_ID_PLAUSIBILITY_CELL_TEMP,
    DIAG_ID_PLAUSIBILITY_CELL_VOLTAGE_SPREAD,
    DIAG_ID_PLAUSIBILITY_CELL_TEMPERATURE_SPREAD,
    DIAG_ID_CELL_VOLTAGE_OVERVOLTAGE_MSL,
    DIAG_ID_CELL_VOLTAGE_OVERVOLTAGE_RSL,
    DIAG_ID_CELL_VOLTAGE_OVERVOLTAGE_MOL,
    DIAG_ID_CELL_VOLTAGE_UNDERVOLTAGE_MSL,
    DIAG_ID_CELL_VOLTAGE_UNDERVOLTAGE_RSL,
    DIAG_ID_CELL_VOLTAGE_UNDERVOLTAGE_MOL,
    DIAG_ID_TEMP_OVERTEMPERATURE_CHARGE_MSL,
    DIAG_ID_TEMP_OVERTEMPERATURE_CHARGE_RSL,
    DIAG_ID_TEMP_OVERTEMPERATURE_CHARGE_MOL,
    DIAG_ID_TEMP_OVERTEMPERATURE_DISCHARGE_MSL,
    DIAG_ID_TEMP_OVERTEMPERATURE_DISCHARGE_RSL,
    DIAG_ID_TEMP_OVERTEMPERATURE_DISCHARGE_MOL,
    DIAG_ID_TEMP_UNDERTEMPERATURE_CHARGE_MSL,
    DIAG_ID_TEMP_UNDERTEMPERATURE_CHARGE_RSL,
    DIAG_ID_TEMP_UNDERTEMPERATURE_CHARGE_MOL,
    DIAG_ID_TEMP_UNDERTEMPERATURE_DISCHARGE_MSL,
    DIAG_ID_TEMP_UNDERTEMPERATURE_DISCHARGE_RSL,
    DIAG_ID_TEMP_UNDERTEMPERATURE_DISCHARGE_MOL,
    DIAG_ID_OVERCURRENT_CHARGE_CELL_MSL,
    DIAG_ID_OVERCURRENT_CHARGE_CELL_RSL,
    DIAG_ID_OVERCURRENT_CHARGE_CELL_MOL,
    DIAG_ID_OVERCURRENT_DISCHARGE_CELL_MSL,
    DIAG_ID_OVERCURRENT_DISCHARGE_CELL_RSL,
    DIAG_ID_OVERCURRENT_DISCHARGE_CELL_MOL,
    DIAG_ID_STRING_OVERCURRENT_CHARGE_MSL,
    DIAG_ID_STRING_OVERCURRENT_CHARGE_RSL,
    DIAG_ID_STRING_OVERCURRENT_CHARGE_MOL,
    DIAG_ID_STRING_OVERCURRENT_DISCHARGE_MSL,
    DIAG_ID_STRING_OVERCURRENT_DISCHARGE_RSL,
    DIAG_ID_STRING_OVERCURRENT_DISCHARGE_MOL,
    DIAG_ID_PACK_OVERCURRENT_CHARGE_MSL,
    DIAG_ID_PACK_OVERCURRENT_DISCHARGE_MSL,
    DIAG_ID_CURRENT_ON_OPEN_STRING,
    DIAG_ID_DEEP_DISCHARGE_DETECTED,
    DIAG_ID_AFE_OPEN_WIRE,
    DIAG_ID_PLAUSIBILITY_PACK_VOLTAGE,
    DIAG_ID_INTERLOCK_FEEDBACK,
    DIAG_ID_STRING_MINUS_CONTACTOR_FEEDBACK,
    DIAG_ID_STRING_PLUS_CONTACTOR_FEEDBACK,
    DIAG_ID_PRECHARGE_CONTACTOR_FEEDBACK,
    DIAG_ID_SBC_FIN_STATE,
    DIAG_ID_SBC_RSTB_STATE,
    DIAG_ID_BASE_CELL_VOLTAGE_MEASUREMENT_TIMEOUT,
    DIAG_ID_REDUNDANCY0_CELL_VOLTAGE_MEASUREMENT_TIMEOUT,
    DIAG_ID_BASE_CELL_TEMPERATURE_MEASUREMENT_TIMEOUT,
    DIAG_ID_REDUNDANCY0_CELL_TEMPERATURE_MEASUREMENT_TIMEOUT,
    DIAG_ID_PRECHARGE_ABORT_REASON_VOLTAGE,
    DIAG_ID_PRECHARGE_ABORT_REASON_CURRENT,
    DIAG_ID_CURRENT_MEASUREMENT_TIMEOUT,
    DIAG_ID_CURRENT_MEASUREMENT_ERROR,
    DIAG_ID_CURRENT_SENSOR_V1_MEASUREMENT_TIMEOUT,
    DIAG_ID_CURRENT_SENSOR_V2_MEASUREMENT_TIMEOUT,
    DIAG_ID_CURRENT_SENSOR_V3_MEASUREMENT_TIMEOUT,
    DIAG_ID_CURRENT_SENSOR_POWER_MEASUREMENT_TIMEOUT,
    DIAG_ID_POWER_MEASUREMENT_ERROR,
    DIAG_ID_INSULATION_MEASUREMENT_VALID,
    DIAG_ID_LOW_INSULATION_RESISTANCE_ERROR,
    DIAG_ID_LOW_INSULATION_RESISTANCE_WARNING,
    DIAG_ID_INSULATION_GROUND_ERROR,
    DIAG_ID_I2C_PEX_ERROR,
    DIAG_ID_I2C_RTC_ERROR,
    DIAG_ID_RTC_CLOCK_INTEGRITY_ERROR,
    DIAG_ID_RTC_BATTERY_LOW_ERROR,
    DIAG_ID_FRAM_READ_CRC_ERROR,
    DIAG_ID_ALERT_MODE,
    DIAG_ID_MAX,
} DIAG_ID_e;
typedef enum {
    DIAG_EVENT_OK,
    DIAG_EVENT_NOT_OK,
    DIAG_EVENT_RESET,
} DIAG_EVENT_e;
typedef enum {
    DIAG_EVALUATION_ENABLED,
    DIAG_EVALUATION_DISABLED,
} DIAG_EVALUATE_e;
typedef enum {
    DIAG_SYSTEM,
    DIAG_STRING,
} DIAG_IMPACT_LEVEL_e;
typedef enum {
    DIAG_FATAL_ERROR,
    DIAG_WARNING,
    DIAG_INFO,
} DIAG_SEVERITY_LEVEL_e;
typedef enum {
    DIAG_RECORDING_ENABLED,
    DIAG_RECORDING_DISABLED,
} DIAG_RECORDING_e;
typedef void DIAG_CALLBACK_FUNCTION_f(
    DIAG_ID_e diagId,
    DIAG_EVENT_e event,
    const DIAG_DATABASE_SHIM_s *const kpkDiagShim,
    uint32_t data);
typedef struct {
    DIAG_ID_e id;
    uint16_t threshold;
    DIAG_SEVERITY_LEVEL_e
        severity;
    uint32_t
        delay_ms;
    DIAG_RECORDING_e enable_recording;
    DIAG_EVALUATE_e enable_evaluate;
    DIAG_CALLBACK_FUNCTION_f *fpCallback;
} DIAG_ID_CFG_s;
typedef struct {
    uint8_t nrOfConfiguredDiagnosisEntries;
    DIAG_ID_CFG_s *pConfigurationOfDiagnosisEntries;
    uint16_t numberOfFatalErrors;
    DIAG_ID_CFG_s *pFatalErrorLinkTable
        [DIAG_ID_MAX];
} DIAG_DEV_s;
extern DIAG_DEV_s diag_device;
extern DIAG_ID_CFG_s diag_diagnosisIdConfiguration[DIAG_ID_MAX];
extern void DIAG_UpdateFlags(void);
typedef enum {
    DIAG_HANDLER_RETURN_OK,
    DIAG_HANDLER_RETURN_ERR_OCCURRED,
    DIAG_HANDLER_RETURN_WARNING_OCCURRED,
    DIAG_HANDLER_RETURN_WRONG_ID,
    DIAG_HANDLER_RETURN_UNKNOWN,
    DIAG_HANDLER_INVALID_TYPE,
    DIAG_HANDLER_INVALID_DATA,
    DIAG_HANDLER_INVALID_ERR_IMPACT,
    DIAG_HANDLER_RETURN_NOT_READY,
} DIAG_RETURNTYPE_e;
typedef enum {
    DIAG_STATE_UNINITIALIZED,
    DIAG_STATE_INITIALIZED,
} DIAG_MODULE_STATE_e;
typedef struct {
    DIAG_MODULE_STATE_e state;
    uint16_t errcnttotal;
    uint16_t errcntreported;
    uint32_t entry_event[DIAG_ID_MAX];
    uint8_t entry_cnt[DIAG_ID_MAX];
    uint16_t occurrenceCounter[(1u)][DIAG_ID_MAX];
    uint8_t id2ch[DIAG_ID_MAX];
    uint8_t nrOfConfiguredDiagnosisEntries;
    uint32_t errflag[(DIAG_ID_MAX + 31) / 32];
    uint32_t warnflag[(DIAG_ID_MAX + 31) / 32];
    uint32_t err_enableflag[(DIAG_ID_MAX + 31) / 32];
} DIAG_DIAGNOSIS_STATE_s;
extern DIAG_RETURNTYPE_e DIAG_Handler(DIAG_ID_e diagId, DIAG_EVENT_e event, DIAG_IMPACT_LEVEL_e impact, uint32_t data);
extern STD_RETURN_TYPE_e DIAG_CheckEvent(
    STD_RETURN_TYPE_e cond,
    DIAG_ID_e diagId,
    DIAG_IMPACT_LEVEL_e impact,
    uint32_t data);
extern STD_RETURN_TYPE_e DIAG_Initialize(DIAG_DEV_s *diag_dev_pointer);
extern STD_RETURN_TYPE_e DIAG_GetDiagnosisEntryState(DIAG_ID_e diagnosisEntry);
extern void DIAG_PrintErrors(void);
extern uint32_t DIAG_GetDelay(DIAG_ID_e diagnosisEntry);
extern _Bool DIAG_IsAnyFatalErrorSet(void);
extern void FRAM_Initialize(void);
extern STD_RETURN_TYPE_e FRAM_ReinitializeAllEntries(void);
extern FRAM_RETURN_TYPE_e FRAM_WriteData(FRAM_BLOCK_ID_e blockId);
extern FRAM_RETURN_TYPE_e FRAM_ReadData(FRAM_BLOCK_ID_e blockId);
extern long FSYS_RaisePrivilege(void);
static inline void FSYS_SwitchToUserMode(void) {
    __asm(" CPS #0x10");
}
extern void IO_SetPinDirectionToOutput(volatile uint32_t *pRegisterAddress, uint32_t pin);
extern void IO_SetPinDirectionToInput(volatile uint32_t *pRegisterAddress, uint32_t pin);
extern void IO_PinSet(volatile uint32_t *pRegisterAddress, uint32_t pin);
extern void IO_PinReset(volatile uint32_t *pRegisterAddress, uint32_t pin);
extern STD_PIN_STATE_e IO_PinGet(const volatile uint32_t *pRegisterAddress, uint32_t pin);
typedef enum {
    MINFO_DEBUG_PROBE_NOT_CONNECTED,
    MINFO_DEBUG_PROBE_CONNECTED,
} MINFO_DEBUG_PROBE_CONNECTION_STATE_e;
typedef struct {
    resetSource_t resetSource;
    MINFO_DEBUG_PROBE_CONNECTION_STATE_e debugProbe;
} MINFO_MASTER_STATE_s;
void MINFO_SetResetSource(resetSource_t resetSource);
resetSource_t MINFO_GetResetSource(void);
void MINFO_SetDebugProbeConnectionState(MINFO_DEBUG_PROBE_CONNECTION_STATE_e state);
MINFO_DEBUG_PROBE_CONNECTION_STATE_e MINFO_GetDebugProbeConnectionState(void);
typedef enum {
    SBC_UNINITIALIZED,
    SBC_FIN_TEST,
    SBC_RSTB_ASSERTION_TEST,
    SBC_INITIALIZED,
} SBC_INIT_PHASE_e;
FS85_STATE_s fs85xx_mcuSupervisor = {
    .pSpiInterface                  = &spi_sbcMcuInterface,
    .configValues.watchdogSeed      = 0x5AB2U,
    .configValues.communicationMode = fs8xSPI,
    .configValues.i2cAddressOtp     = 0,
    .fin.finUsed                    = 0,
    .fin.finState                   = STD_NOT_OK,
    .fin.pGIOport = &(((systemBASE1_t *)0xFFFFFF00U)->SYSPC4),
    .fin.pin      = 0,
    .mainRegister = {0},
    .fsRegister   = {0},
    .nvram.entry  = FRAM_BLOCK_ID_SBC_INIT_STATE,
    .nvram.data   = &fram_sbcInit,
    .mode         = SBC_NORMAL_MODE,
};
static STD_RETURN_TYPE_e SBC_CheckRegisterValues(uint32_t registerValue, uint32_t expectedRegisterValue);
static void SBC_UpdateFailSafeRegister(
    FS85_FS_REGISTER_s *pFsRegister,
    uint32_t registerAddress,
    uint32_t registerValue);
static void SBC_UpdateMainRegister(
    FS85_MAIN_REGISTERS_s *pMainRegister,
    uint32_t registerAddress,
    uint32_t registerValue);
static void SBC_UpdateRegister(
    FS85_STATE_s *pInstance,
    _Bool isFailSafe,
    uint32_t registerAddress,
    uint32_t registerValue);
static STD_RETURN_TYPE_e SBC_ReadBackRegister(FS85_STATE_s *pInstance, _Bool isFailSafe, uint8_t registerAddress);
static STD_RETURN_TYPE_e SBC_WriteRegisterFsInit(
    FS85_STATE_s *pInstance,
    uint8_t registerAddress,
    uint16_t registerValue);
static STD_RETURN_TYPE_e SBC_WriteBackRegisterFsInit(
    FS85_STATE_s *pInstance,
    uint8_t registerAddress,
    uint16_t registerValue);
static STD_RETURN_TYPE_e SBC_ClearRegisterFlags(
    FS85_STATE_s *pInstance,
    uint8_t registerAddress,
    _Bool isFailSafe,
    uint16_t registerValue);
static STD_RETURN_TYPE_e SBC_ReadBackAllRegisters(FS85_STATE_s *pInstance);
static STD_RETURN_TYPE_e SBC_PerformPathCheckRstb(FS85_STATE_s *pInstance);
static STD_RETURN_TYPE_e SBC_PerformPathCheckFs0b(FS85_STATE_s *pInstance);
static STD_RETURN_TYPE_e SBC_CheckRegisterValues(uint32_t registerValue, uint32_t expectedRegisterValue) {
    STD_RETURN_TYPE_e retval = STD_OK;
    if (registerValue != expectedRegisterValue) {
        retval = STD_NOT_OK;
    }
    return retval;
}
static void SBC_UpdateFailSafeRegister(
    FS85_FS_REGISTER_s *pFsRegister,
    uint32_t registerAddress,
    uint32_t registerValue) {
    do { if (!(pFsRegister != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 249); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!(registerAddress <= 0x25U)) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 250); } while (0); FAS_InfiniteLoop(); } } while (0);
    switch (registerAddress) {
        case 0x00U:
            pFsRegister->grl_flags = registerValue;
            break;
        case 0x01U:
            pFsRegister->iOvervoltageUndervoltageSafeReaction1 = registerValue;
            break;
        case 0x03U:
            pFsRegister->iOvervoltageUndervoltageSafeReaction2 = registerValue;
            break;
        case 0x05U:
            pFsRegister->iWatchdogConfiguration = registerValue;
            break;
        case 0x07U:
            pFsRegister->i_safe_inputs = registerValue;
            break;
        case 0x09U:
            pFsRegister->iFailSafeSateMachine = registerValue;
            break;
        case 0x0BU:
            pFsRegister->i_svs = registerValue;
            break;
        case 0x0DU:
            pFsRegister->watchdogWindow = registerValue;
            break;
        case 0x0FU:
            pFsRegister->watchdogSeed = registerValue;
            break;
        case 0x10U:
            pFsRegister->watchdogAnswer = registerValue;
            break;
        case 0x11U:
            pFsRegister->overvoltageUndervoltageRegisterStatus = registerValue;
            break;
        case 0x12U:
            pFsRegister->releaseFs0bPin = registerValue;
            break;
        case 0x13U:
            pFsRegister->safeIos = registerValue;
            break;
        case 0x14U:
            pFsRegister->diag_safety = registerValue;
            break;
        case 0x15U:
            pFsRegister->intb_mask = registerValue;
            break;
        case 0x16U:
            pFsRegister->states = registerValue;
            break;
        default:
            do { if (!((0u == 1u))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 302); } while (0); FAS_InfiniteLoop(); } } while (0);
            break;
    }
}
static void SBC_UpdateMainRegister(
    FS85_MAIN_REGISTERS_s *pMainRegister,
    uint32_t registerAddress,
    uint32_t registerValue) {
    do { if (!(pMainRegister != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 311); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!(registerAddress <= 0x25U)) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 312); } while (0); FAS_InfiniteLoop(); } } while (0);
    switch (registerAddress) {
        case 0x00U:
            pMainRegister->flag = registerValue;
            break;
        case 0x01U:
            pMainRegister->mode = registerValue;
            break;
        case 0x02U:
            pMainRegister->registerControl1 = registerValue;
            break;
        case 0x03U:
            pMainRegister->registerControl2 = registerValue;
            break;
        case 0x04U:
            pMainRegister->analogMultiplexer = registerValue;
            break;
        case 0x05U:
            pMainRegister->clock = registerValue;
            break;
        case 0x06U:
            pMainRegister->int_mask1 = registerValue;
            break;
        case 0x07U:
            pMainRegister->int_mask2 = registerValue;
            break;
        case 0x08U:
            pMainRegister->flag1 = registerValue;
            break;
        case 0x09U:
            pMainRegister->flag2 = registerValue;
            break;
        case 0x0AU:
            pMainRegister->vmon_regx = registerValue;
            break;
        case 0x0BU:
            pMainRegister->lvb1_svs = registerValue;
            break;
        case 0x23U:
            pMainRegister->memory0 = registerValue;
            break;
        case 0x24U:
            pMainRegister->memory1 = registerValue;
            break;
        case 0x25U:
            pMainRegister->deviceId = registerValue;
            break;
        default:
            do { if (!((0u == 1u))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 361); } while (0); FAS_InfiniteLoop(); } } while (0);
            break;
    }
}
static void SBC_UpdateRegister(
    FS85_STATE_s *pInstance,
    _Bool isFailSafe,
    uint32_t registerAddress,
    uint32_t registerValue) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 371); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!((isFailSafe == 1) || (isFailSafe == 0))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 372); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!(registerAddress <= 0x25U)) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 373); } while (0); FAS_InfiniteLoop(); } } while (0);
    if (isFailSafe == 1) {
        SBC_UpdateFailSafeRegister(&(pInstance->fsRegister), registerAddress, registerValue);
    } else {
        SBC_UpdateMainRegister(&(pInstance->mainRegister), registerAddress, registerValue);
    }
}
static STD_RETURN_TYPE_e SBC_ReadBackRegister(FS85_STATE_s *pInstance, _Bool isFailSafe, uint8_t registerAddress) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 385); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!((isFailSafe == 1) || (isFailSafe == 0))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 386); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_NOT_OK;
    fs8x_rx_frame_t rxTemp   = {0};
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 392); } while (0); FAS_InfiniteLoop(); } } while (0);
    if (fs8xStatusOk !=
        FS8x_ReadRegister(pInstance->pSpiInterface, &(pInstance->configValues), isFailSafe, registerAddress, &rxTemp)) {
        retval = STD_NOT_OK;
    } else {
        SBC_UpdateRegister(pInstance, isFailSafe, registerAddress, rxTemp.readData);
        retval = STD_OK;
    }
    return retval;
}
static STD_RETURN_TYPE_e SBC_WriteRegisterFsInit(
    FS85_STATE_s *pInstance,
    uint8_t registerAddress,
    uint16_t registerValue) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 408); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 414); } while (0); FAS_InfiniteLoop(); } } while (0);
    if (fs8xStatusOk !=
        FS8x_WriteRegisterInit(pInstance->pSpiInterface, &(pInstance->configValues), registerAddress, registerValue)) {
        retval = STD_NOT_OK;
    } else {
        retval = STD_OK;
    }
    return retval;
}
static STD_RETURN_TYPE_e SBC_WriteBackRegisterFsInit(
    FS85_STATE_s *pInstance,
    uint8_t registerAddress,
    uint16_t registerValue) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 430); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    fs8x_rx_frame_t rxTemp   = {0};
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 437); } while (0); FAS_InfiniteLoop(); } } while (0);
    if (fs8xStatusOk !=
        FS8x_WriteRegisterInit(pInstance->pSpiInterface, &(pInstance->configValues), registerAddress, registerValue)) {
        retval |= STD_NOT_OK;
    } else {
        if (fs8xStatusOk !=
            FS8x_ReadRegister(pInstance->pSpiInterface, &(pInstance->configValues), 1, registerAddress, &rxTemp)) {
            retval |= STD_NOT_OK;
        } else {
            if (rxTemp.readData == registerValue) {
                SBC_UpdateRegister(pInstance, 1, registerAddress, rxTemp.readData);
            } else {
                retval |= STD_NOT_OK;
            }
        }
    }
    return retval;
}
static STD_RETURN_TYPE_e SBC_ClearRegisterFlags(
    FS85_STATE_s *pInstance,
    uint8_t registerAddress,
    _Bool isFailSafe,
    uint16_t registerValue) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 465); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    fs8x_rx_frame_t rxTemp   = {0};
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 473); } while (0); FAS_InfiniteLoop(); } } while (0);
    if (fs8xStatusOk !=
        FS8x_WriteRegister(
            pInstance->pSpiInterface, &(pInstance->configValues), isFailSafe, registerAddress, registerValue)) {
        retval |= STD_NOT_OK;
    } else {
        if (fs8xStatusOk !=
            FS8x_ReadRegister(
                pInstance->pSpiInterface, &(pInstance->configValues), isFailSafe, registerAddress, &rxTemp)) {
            retval |= STD_NOT_OK;
        } else {
            if ((rxTemp.readData & registerValue) == 0u) {
                SBC_UpdateRegister(pInstance, isFailSafe, registerAddress, rxTemp.readData);
            } else {
                retval |= STD_NOT_OK;
            }
        }
    }
    return retval;
}
extern STD_RETURN_TYPE_e FS85_InitializeFsPhase(FS85_STATE_s *pInstance) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 501); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval  = STD_OK;
    uint16_t registerMask     = 0u;
    uint16_t expRegisterValue = 0u;
    uint16_t registerValue    = 0u;
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 508); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!(pInstance ->fin . finState == STD_NOT_OK)) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 512); } while (0); FAS_InfiniteLoop(); } } while (0);
    if (STD_OK != SBC_ReadBackRegister(pInstance, 1, 0x14U)) {
        retval = STD_NOT_OK;
    }
    registerMask     = (0x0001U | 0x0080U);
    expRegisterValue = ((0x0001U << 0x0000U) | (0x0001U << 0x0007U));
    if (STD_OK != SBC_CheckRegisterValues((pInstance->fsRegister.diag_safety & registerMask), expRegisterValue)) {
        retval = STD_NOT_OK;
    }
    if (STD_OK != SBC_ReadBackRegister(pInstance, 1, 0x16U)) {
        retval = STD_NOT_OK;
    }
    registerMask     = 0x2000U;
    expRegisterValue = (0x0000U << 0x000DU);
    if (STD_OK != SBC_CheckRegisterValues((pInstance->fsRegister.states & registerMask), expRegisterValue)) {
        MINFO_SetDebugProbeConnectionState(MINFO_DEBUG_PROBE_CONNECTED);
        pInstance->mode = SBC_DEBUG_MODE;
    } else {
        MINFO_SetDebugProbeConnectionState(MINFO_DEBUG_PROBE_NOT_CONNECTED);
        pInstance->mode = SBC_NORMAL_MODE;
    }
    registerMask     = 0x0800U;
    expRegisterValue = (0x0000U << 0x000BU);
    if (STD_OK != SBC_CheckRegisterValues((pInstance->fsRegister.states & registerMask), expRegisterValue)) {
        retval = STD_NOT_OK;
    }
    registerMask     = 0x001FU;
    expRegisterValue = (0x0006U << 0x0000U);
    if (STD_OK != SBC_CheckRegisterValues((pInstance->fsRegister.states & registerMask), expRegisterValue)) {
        registerValue = (0x0001U << 0x0002U);
        if (STD_OK != SBC_WriteRegisterFsInit(pInstance, 0x13U, registerValue)) {
            retval = STD_NOT_OK;
        } else {
            if (STD_OK != SBC_ReadBackRegister(pInstance, 1, 0x16U)) {
                retval = STD_NOT_OK;
            } else {
                if (STD_OK !=
                    SBC_CheckRegisterValues((pInstance->fsRegister.states & registerMask), expRegisterValue)) {
                    retval = STD_NOT_OK;
                }
            }
        }
    }
    registerValue = 0;
    registerValue |= (0x0000U << 0x000EU);
    registerValue |= (0x0000U << 0x000CU);
    registerValue |= (0x0000U << 0x0002U);
    registerValue |= (0x0000U << 0x0000U);
    registerValue |= (0x0001U << 0x000AU);
    registerValue |= (0x0001U << 0x0009U);
    registerValue |= (0x0001U << 0x0008U);
    registerValue |= (0x0001U << 0x0007U);
    registerValue |= (0x0001U << 0x0006U);
    registerValue |= (0x0001U << 0x0005U);
    if (STD_OK != SBC_WriteBackRegisterFsInit(pInstance, 0x01U, registerValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = 0;
    registerValue |= (0x0000U << 0x0002U);
    registerValue |= (0x0000U << 0x0006U);
    registerValue |= (0x0000U << 0x000AU);
    registerValue |= (0x0000U << 0x000EU);
    registerValue |= (0x0000U << 0x0000U);
    registerValue |= (0x0000U << 0x0004U);
    registerValue |= (0x0000U << 0x0008U);
    registerValue |= (0x0000U << 0x000CU);
    if (STD_OK != SBC_WriteBackRegisterFsInit(pInstance, 0x03U, registerValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = 0;
    registerValue |= (0x000CU << 0x000CU);
    registerValue |= (0x0002U << 0x0008U);
    registerValue |= (0x000CU << 0x0000U);
    if (STD_OK != SBC_WriteBackRegisterFsInit(pInstance, 0x0DU, registerValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = 0;
    registerValue |= (0x0002U << 0x000EU);
    registerValue |= (0x0002U << 0x000BU);
    registerValue |= (0x0000U << 0x0009U);
    registerValue |= (0x0000U << 0x0007U);
    registerValue |= (0x0001U << 0x0000U);
    if (STD_OK != SBC_WriteRegisterFsInit(pInstance, 0x09U, registerValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = 0;
    registerValue |= (0x0000U << 0x000EU);
    registerValue |= (0x0000U << 0x000BU);
    registerValue |= (0x0000U << 0x0007U);
    registerValue |= (0x0001U << 0x0004U);
    registerValue |= (0x0003U << 0x0002U);
    registerValue |= (0x0000U << 0x0001U);
    if (STD_OK != SBC_WriteRegisterFsInit(pInstance, 0x07U, registerValue)) {
        retval = STD_NOT_OK;
    }
    if (STD_OK != SBC_TriggerWatchdog(pInstance)) {
        retval = STD_NOT_OK;
    }
    MCU_Delay_us(1200u);
    if (STD_OK != SBC_ReadBackRegister(pInstance, 1, 0x14U)) {
        retval = STD_NOT_OK;
    }
    registerMask     = 0x0040U;
    expRegisterValue = 0x0040U;
    if (STD_OK != SBC_CheckRegisterValues((pInstance->fsRegister.diag_safety & registerMask), expRegisterValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = 0;
    registerValue |= ((0x0001U << 0x000FU) | (0x0001U << 0x000EU) | (0x0001U << 0x000DU));
    registerValue |= (0x0001U << 0x000BU);
    registerValue |= ((0x0001U << 0x0009U) | (0x0001U << 0x0008U));
    registerValue |=
        ((0x0001U << 0x0005U) | (0x0001U << 0x0004U) |
         (0x0001U << 0x0003U));
    registerValue |= ((0x0001U << 0x0002U) | (0x0001U << 0x0001U));
    if (STD_OK != SBC_ClearRegisterFlags(pInstance, 0x14U, 1, registerValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = 0;
    registerValue |= ((0x0001U << 0x000FU) | (0x0001U << 0x000EU));
    registerValue |= ((0x0001U << 0x000DU) | (0x0001U << 0x000CU));
    registerValue |=
        ((0x0001U << 0x000BU) | (0x0001U << 0x000AU) |
         (0x0001U << 0x0009U) | (0x0001U << 0x0008U) |
         (0x0001U << 0x0007U) | (0x0001U << 0x0006U) |
         (0x0001U << 0x0005U) | (0x0001U << 0x0004U));
    registerValue |= (0x0001U << 0x0002U);
    registerValue |= (0x0001U << 0x0001U);
    if (STD_OK != SBC_ClearRegisterFlags(pInstance, 0x11U, 1, registerValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = (0x0001U << 0x000FU);
    registerValue |= (0x0001U << 0x000EU);
    if (STD_OK != SBC_ClearRegisterFlags(pInstance, 0x08U, 0, registerValue)) {
        retval = STD_NOT_OK;
    }
    registerValue = (0x0001U << 0x000EU);
    registerValue |=
        ((0x0001U << 0x0007U) | (0x0001U << 0x0006U) | (0x0001U << 0x0005U) |
         (0x0001U << 0x0004U) | (0x0001U << 0x0001U));
    if (STD_OK != SBC_ClearRegisterFlags(pInstance, 0x09U, 0, registerValue)) {
        retval = STD_NOT_OK;
    }
    if (STD_OK != SBC_ReadBackAllRegisters(pInstance)) {
        retval = STD_OK;
    }
    return retval;
}
extern STD_RETURN_TYPE_e FS85_InitializeNumberOfRequiredWatchdogRefreshes(
    FS85_STATE_s *pInstance,
    uint8_t *requiredWatchdogRefreshes) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 888); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!(requiredWatchdogRefreshes != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 889); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    if (STD_OK != SBC_ReadBackRegister(pInstance, 1, 0x05U)) {
        retval = STD_NOT_OK;
    }
    uint8_t watchdogRefreshLimit   = 0;
    uint8_t watchdogRefreshCounter = (((pInstance ->fsRegister . iWatchdogConfiguration) & (0x0070U)) >> (0x0004U));
    if ((0x0000U << 0x000BU) ==
        (((pInstance ->fsRegister . iWatchdogConfiguration) & (0x1800U)) >> (0x000BU))) {
        watchdogRefreshLimit = 6u;
    } else if (
        (0x0001U << 0x000BU) ==
        (((pInstance ->fsRegister . iWatchdogConfiguration) & (0x1800U)) >> (0x000BU))) {
        watchdogRefreshLimit = 4u;
    } else if (
        (0x0002U << 0x000BU) ==
        (((pInstance ->fsRegister . iWatchdogConfiguration) & (0x1800U)) >> (0x000BU))) {
        watchdogRefreshLimit = 2u;
    } else {
        watchdogRefreshLimit = 1u;
    }
    uint8_t faultCounter = 0u;
    if (fs8xStatusOk !=
        FS8x_GetFaultErrorCounterValue(pInstance->pSpiInterface, &(pInstance->configValues), &faultCounter)) {
        retval = STD_NOT_OK;
    }
    *requiredWatchdogRefreshes = faultCounter + (watchdogRefreshLimit - watchdogRefreshCounter);
    return retval;
}
extern STD_RETURN_TYPE_e FS85_CheckFaultErrorCounter(FS85_STATE_s *pInstance) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 943); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    uint8_t faultCounter = 0u;
    retval |= FS8x_GetFaultErrorCounterValue(pInstance->pSpiInterface, &(pInstance->configValues), &faultCounter);
    if (faultCounter != 0u) {
        retval = STD_NOT_OK;
    }
    return retval;
}
extern STD_RETURN_TYPE_e FS85_SafetyPathChecks(FS85_STATE_s *pInstance) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 958); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    if (STD_OK != SBC_PerformPathCheckRstb(pInstance)) {
        retval = STD_NOT_OK;
    }
    if (pInstance->mode != SBC_DEBUG_MODE) {
        if (fs8xStatusOk != FS8x_FS0B_Release(pInstance->pSpiInterface, &(pInstance->configValues))) {
            retval = STD_NOT_OK;
        }
    }
    if (STD_OK != SBC_PerformPathCheckFs0b(pInstance)) {
        retval = STD_NOT_OK;
    }
    if (retval == STD_OK) {
        pInstance->nvram.data->phase = (uint8_t)SBC_INITIALIZED;
        FRAM_WriteData(pInstance->nvram.entry);
    }
    return retval;
}
extern  fs8x_status_t MCU_SPI_TransferData(
    SPI_INTERFACE_CONFIG_s *pSpiInterface,
    uint8_t *txFrame,
    uint16_t frameLengthBytes,
    uint8_t *rxFrame) {
    do { if (!(pSpiInterface != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 994); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!(txFrame != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 995); } while (0); FAS_InfiniteLoop(); } } while (0);
    do { if (!(rxFrame != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 996); } while (0); FAS_InfiniteLoop(); } } while (0);
    uint16_t sbc_txBuffer[(0x04U)];
    uint16_t sbc_rxBuffer[(0x04U)];
    fs8x_status_t spiCommunicationState = fs8xStatusError;
    for (uint8_t i = 0u; i < (0x04U); i++) {
        sbc_txBuffer[(0x04U) - 1u - i] = (uint16_t)txFrame[i];
        sbc_rxBuffer[i]                             = 0;
    }
    STD_RETURN_TYPE_e spiRetval =
        SPI_TransmitReceiveData(pSpiInterface, sbc_txBuffer, sbc_rxBuffer, (0x04U));
    if (spiRetval == STD_OK) {
        for (uint8_t i = 0u; i < (0x04U); i++) {
            rxFrame[i] = (uint8_t)sbc_rxBuffer[(0x04U) - 1u - i];
        }
        spiCommunicationState = fs8xStatusOk;
    }
    return spiCommunicationState;
}
extern STD_RETURN_TYPE_e SBC_TriggerWatchdog(FS85_STATE_s *pInstance) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 1024); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_NOT_OK;
    if (fs8xStatusOk == FS8x_WD_Refresh(pInstance->pSpiInterface, &(pInstance->configValues))) {
        if (STD_OK == SBC_ReadBackRegister(pInstance, 1, 0x00U)) {
            uint16_t registerMask     = 0x4000U;
            uint16_t expRegisterValue = (0x0000U << 0x000EU);
            if (STD_OK == SBC_CheckRegisterValues((pInstance->fsRegister.grl_flags & registerMask), expRegisterValue)) {
                retval = STD_OK;
            } else {
                if (STD_OK == SBC_ReadBackRegister(pInstance, 1, 0x14U)) {
                    registerMask     = 0x0100U;
                    expRegisterValue = (0x0001U << 0x0008U);
                    if (STD_OK ==
                        SBC_CheckRegisterValues((pInstance->fsRegister.diag_safety & registerMask), expRegisterValue)) {
                    }
                    registerMask     = 0x0200U;
                    expRegisterValue = (0x0001U << 0x0009U);
                    if (STD_OK ==
                        SBC_CheckRegisterValues((pInstance->fsRegister.diag_safety & registerMask), expRegisterValue)) {
                    }
                }
            }
        }
    }
    return retval;
}
static STD_RETURN_TYPE_e SBC_ReadBackAllRegisters(FS85_STATE_s *pInstance) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 1058); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    SBC_ReadBackRegister(pInstance, 1, 0x00U);
    SBC_ReadBackRegister(pInstance, 1, 0x01U);
    SBC_ReadBackRegister(pInstance, 1, 0x03U);
    SBC_ReadBackRegister(pInstance, 1, 0x05U);
    SBC_ReadBackRegister(pInstance, 1, 0x07U);
    SBC_ReadBackRegister(pInstance, 1, 0x09U);
    SBC_ReadBackRegister(pInstance, 1, 0x0BU);
    SBC_ReadBackRegister(pInstance, 1, 0x0DU);
    SBC_ReadBackRegister(pInstance, 1, 0x0FU);
    SBC_ReadBackRegister(pInstance, 1, 0x10U);
    SBC_ReadBackRegister(pInstance, 1, 0x11U);
    SBC_ReadBackRegister(pInstance, 1, 0x12U);
    SBC_ReadBackRegister(pInstance, 1, 0x13U);
    SBC_ReadBackRegister(pInstance, 1, 0x14U);
    SBC_ReadBackRegister(pInstance, 1, 0x15U);
    SBC_ReadBackRegister(pInstance, 1, 0x16U);
    SBC_ReadBackRegister(pInstance, 0, 0x00U);
    SBC_ReadBackRegister(pInstance, 0, 0x01U);
    SBC_ReadBackRegister(pInstance, 0, 0x02U);
    SBC_ReadBackRegister(pInstance, 0, 0x03U);
    SBC_ReadBackRegister(pInstance, 0, 0x04U);
    SBC_ReadBackRegister(pInstance, 0, 0x05U);
    SBC_ReadBackRegister(pInstance, 0, 0x06U);
    SBC_ReadBackRegister(pInstance, 0, 0x07U);
    SBC_ReadBackRegister(pInstance, 0, 0x08U);
    SBC_ReadBackRegister(pInstance, 0, 0x09U);
    SBC_ReadBackRegister(pInstance, 0, 0x0AU);
    SBC_ReadBackRegister(pInstance, 0, 0x0BU);
    SBC_ReadBackRegister(pInstance, 0, 0x23U);
    SBC_ReadBackRegister(pInstance, 0, 0x24U);
    SBC_ReadBackRegister(pInstance, 0, 0x25U);
    return retval;
}
static STD_RETURN_TYPE_e SBC_PerformPathCheckRstb(FS85_STATE_s *pInstance) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 1100); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    resetSource_t rstReason  = MINFO_GetResetSource();
    _Bool test_assertionRSTB  = 0;
    if (rstReason == POWERON_RESET) {
        if (pInstance->fin.finUsed == 1) {
            pInstance->nvram.data->phase = (uint8_t)SBC_FIN_TEST;
            FRAM_WriteData(pInstance->nvram.entry);
            FSYS_RaisePrivilege();
            IO_PinReset(pInstance->fin.pGIOport, pInstance->fin.pin);
            MCU_Delay_us(10u);
            IO_PinSet(pInstance->fin.pGIOport, pInstance->fin.pin);
            FSYS_SwitchToUserMode();
            DIAG_Handler(DIAG_ID_SBC_FIN_STATE, DIAG_EVENT_OK, DIAG_SYSTEM, 0);
            pInstance->fin.finState         = STD_OK;
            pInstance->nvram.data->finState = STD_OK;
            test_assertionRSTB = 0;
        } else {
            test_assertionRSTB = 0;
        }
    } else if (rstReason == EXT_RESET) {
        FRAM_ReadData(pInstance->nvram.entry);
        if ((SBC_INIT_PHASE_e)pInstance->nvram.data->phase == SBC_FIN_TEST) {
            pInstance->nvram.data->finState = STD_NOT_OK;
            test_assertionRSTB = 0;
        } else if ((SBC_INIT_PHASE_e)pInstance->nvram.data->phase == SBC_RSTB_ASSERTION_TEST) {
            test_assertionRSTB = 0;
            SBC_ReadBackRegister(pInstance, 1, 0x13U);
            if (STD_OK ==
                SBC_CheckRegisterValues(
                    (pInstance->fsRegister.safeIos & 0x0200U), (0x0001U << 0x0009U))) {
                uint16_t mask = (0x0100U | 0x0400U | 0x0800U);
                uint16_t expRegisterValue =
                    ((0x0000U << 0x0008U) | (0x0001U << 0x000AU) |
                     (0x0001U << 0x000BU));
                if (STD_OK != SBC_CheckRegisterValues((pInstance->fsRegister.safeIos & mask), expRegisterValue)) {
                    retval = STD_NOT_OK;
                }
                SBC_WriteBackRegisterFsInit(pInstance, 0x13U, (0x0001U << 0x0009U));
                DIAG_Handler(DIAG_ID_SBC_RSTB_STATE, DIAG_EVENT_OK, DIAG_SYSTEM, 0);
            } else {
                retval = STD_NOT_OK;
                DIAG_Handler(DIAG_ID_SBC_RSTB_STATE, DIAG_EVENT_NOT_OK, DIAG_SYSTEM, 0);
            }
        } else {
            test_assertionRSTB = 0;
        }
        pInstance->fin.finState = pInstance->nvram.data->finState;
        if (pInstance->fin.finState == STD_OK) {
            DIAG_Handler(DIAG_ID_SBC_FIN_STATE, DIAG_EVENT_OK, DIAG_SYSTEM, 0);
        } else {
            DIAG_Handler(DIAG_ID_SBC_FIN_STATE, DIAG_EVENT_NOT_OK, DIAG_SYSTEM, 0);
        }
    } else {
        FRAM_ReadData(pInstance->nvram.entry);
        test_assertionRSTB      = 0;
        pInstance->fin.finState = pInstance->nvram.data->finState;
        if (pInstance->fin.finState == STD_OK) {
            DIAG_Handler(DIAG_ID_SBC_FIN_STATE, DIAG_EVENT_OK, DIAG_SYSTEM, 0);
        } else {
            DIAG_Handler(DIAG_ID_SBC_FIN_STATE, DIAG_EVENT_NOT_OK, DIAG_SYSTEM, 0);
        }
    }
    if (test_assertionRSTB == 1) {
        pInstance->nvram.data->phase = (uint8_t)SBC_RSTB_ASSERTION_TEST;
        FRAM_WriteData(pInstance->nvram.entry);
        SBC_ReadBackRegister(pInstance, 1, 0x16U);
        uint16_t registerValue = (0x0001U << 0x0007U);
        SBC_WriteRegisterFsInit(pInstance, 0x13U, registerValue);
        while (1) {
            ;
        }
    }
    return retval;
}
static STD_RETURN_TYPE_e SBC_PerformPathCheckFs0b(FS85_STATE_s *pInstance) {
    do { if (!(pInstance != ((void *)(0u)))) { do { uint32_t *pc = (uint32_t *)__curpc(); FAS_StoreAssertLocation(pc, 1233); } while (0); FAS_InfiniteLoop(); } } while (0);
    STD_RETURN_TYPE_e retval = STD_OK;
    return retval;
}
