typedef int ptrdiff_t;
typedef unsigned size_t;
typedef unsigned short wchar_t;
typedef long double max_align_t;
typedef	signed char		__int8_t;
typedef	unsigned char		__uint8_t;
typedef	short			__int16_t;
typedef	unsigned short		__uint16_t;
typedef	int			__int32_t;
typedef	unsigned int		__uint32_t;
typedef	long long		__int64_t;
typedef	unsigned long long	__uint64_t;
typedef	__uint32_t	__clock_t;
typedef	__int32_t	__critical_t;
typedef	double		__double_t;
typedef	float		__float_t;
typedef	__int32_t	__intfptr_t;
typedef	__int64_t	__intmax_t;
typedef	__int32_t	__intptr_t;
typedef	__int32_t	__int_fast8_t;
typedef	__int32_t	__int_fast16_t;
typedef	__int32_t	__int_fast32_t;
typedef	__int64_t	__int_fast64_t;
typedef	__int8_t	__int_least8_t;
typedef	__int16_t	__int_least16_t;
typedef	__int32_t	__int_least32_t;
typedef	__int64_t	__int_least64_t;
typedef	__int32_t	__ptrdiff_t;
typedef	__int32_t	__register_t;
typedef	__int32_t	__segsz_t;
typedef	__uint32_t	__size_t;
typedef	__int32_t	__ssize_t;
typedef __uint32_t      __time_t;
typedef	__uint32_t	__uintfptr_t;
typedef	__uint64_t	__uintmax_t;
typedef	__uint32_t	__uintptr_t;
typedef	__uint32_t	__uint_fast8_t;
typedef	__uint32_t	__uint_fast16_t;
typedef	__uint32_t	__uint_fast32_t;
typedef	__uint64_t	__uint_fast64_t;
typedef	__uint8_t	__uint_least8_t;
typedef	__uint16_t	__uint_least16_t;
typedef	__uint32_t	__uint_least32_t;
typedef	__uint64_t	__uint_least64_t;
typedef	__uint32_t	__u_register_t;
typedef	__uint32_t	__vm_offset_t;
typedef	__uint32_t	__vm_paddr_t;
typedef	__uint32_t	__vm_size_t;
typedef	unsigned short ___wchar_t;
typedef long _off_t;
typedef struct __va_list_t {
    void * __ap;
} __va_list;
typedef	__int32_t	__blksize_t;
typedef	__int64_t	__blkcnt_t;
typedef	__int32_t	__clockid_t;
typedef	__uint32_t	__fflags_t;
typedef	__uint64_t	__fsblkcnt_t;
typedef	__uint64_t	__fsfilcnt_t;
typedef	__uint32_t	__gid_t;
typedef	__int64_t	__id_t;
typedef	__uint64_t	__ino_t;
typedef	long		__key_t;
typedef	__int32_t	__lwpid_t;
typedef	__uint16_t	__mode_t;
typedef	int		__accmode_t;
typedef	int		__nl_item;
typedef	__uint64_t	__nlink_t;
typedef	_off_t	        __off_t;
typedef	__int64_t	__off64_t;
typedef	__int32_t	__pid_t;
typedef	__int64_t	__rlim_t;
typedef	__uint8_t	__sa_family_t;
typedef	__uint32_t	__socklen_t;
typedef	long		__suseconds_t;
typedef	struct __timer	*__timer_t;
typedef	struct __mq	*__mqd_t;
typedef	__uint32_t	__uid_t;
typedef	unsigned int	__useconds_t;
typedef	int		__cpuwhich_t;
typedef	int		__cpulevel_t;
typedef int		__cpusetid_t;
typedef	int		__ct_rune_t;
typedef	__ct_rune_t	__rune_t;
typedef	__ct_rune_t	__wint_t;
typedef	__uint_least16_t __char16_t;
typedef	__uint_least32_t __char32_t;
typedef struct {
	long long __max_align1 ;
	long double __max_align2 ;
} __max_align_t;
typedef	__uint64_t	__dev_t;
typedef	__uint32_t	__fixpt_t;
typedef int _Mbstatet;
typedef _Mbstatet __mbstate_t;
typedef __uintmax_t     __rman_res_t;
typedef	__int8_t		int8_t;
typedef	__int16_t		int16_t;
typedef	__int32_t		int32_t;
typedef	__int64_t		int64_t;
typedef	__uint8_t		uint8_t;
typedef	__uint16_t		uint16_t;
typedef	__uint32_t		uint32_t;
typedef	__uint64_t		uint64_t;
typedef	__intptr_t		intptr_t;
typedef	__uintptr_t		uintptr_t;
typedef	__intmax_t		intmax_t;
typedef	__uintmax_t		uintmax_t;
typedef	__int_least8_t		int_least8_t;
typedef	__int_least16_t		int_least16_t;
typedef	__int_least32_t		int_least32_t;
typedef	__int_least64_t		int_least64_t;
typedef	__uint_least8_t		uint_least8_t;
typedef	__uint_least16_t	uint_least16_t;
typedef	__uint_least32_t	uint_least32_t;
typedef	__uint_least64_t	uint_least64_t;
typedef	__int_fast8_t		int_fast8_t;
typedef	__int_fast16_t		int_fast16_t;
typedef	__int_fast32_t		int_fast32_t;
typedef	__int_fast64_t		int_fast64_t;
typedef	__uint_fast8_t		uint_fast8_t;
typedef	__uint_fast16_t		uint_fast16_t;
typedef	__uint_fast32_t		uint_fast32_t;
typedef	__uint_fast64_t		uint_fast64_t;
typedef void (* TaskFunction_t)( void * );
typedef uint32_t   StackType_t;
typedef long             BaseType_t;
typedef unsigned long    UBaseType_t;
    typedef uint32_t     TickType_t;
extern void vPortEnterCritical( void );
extern void vPortExitCritical( void );
extern void vPortDisableInterrupts( void );
extern void vPortEnableInterrupts( void );
extern void vPortYield( void );
extern void vPortTaskUsesFPU( void );
    unsigned long ulPortCountLeadingZeros( unsigned long ulBitmap );
typedef struct MPU_REGION_REGISTERS
{
    unsigned ulRegionBaseAddress;
    unsigned ulRegionSize;
    unsigned ulRegionAttribute;
} xMPU_REGION_REGISTERS;
typedef struct MPU_SETTINGS
{
    xMPU_REGION_REGISTERS xRegion[ ( ( ( ( ( 16UL ) - 2 ) - ( 13UL - 1UL ) ) + 1 ) + 1 ) ];
} xMPU_SETTINGS;
        StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                             TaskFunction_t pxCode,
                                             void * pvParameters,
                                             BaseType_t xRunPrivileged ) ;
typedef struct HeapRegion
{
    uint8_t * pucStartAddress;
    size_t xSizeInBytes;
} HeapRegion_t;
typedef struct xHeapStats
{
    size_t xAvailableHeapSpaceInBytes;
    size_t xSizeOfLargestFreeBlockInBytes;
    size_t xSizeOfSmallestFreeBlockInBytes;
    size_t xNumberOfFreeBlocks;
    size_t xMinimumEverFreeBytesRemaining;
    size_t xNumberOfSuccessfulAllocations;
    size_t xNumberOfSuccessfulFrees;
} HeapStats_t;
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
void vPortGetHeapStats( HeapStats_t * pxHeapStats );
void * pvPortMalloc( size_t xSize ) ;
void vPortFree( void * pv ) ;
void vPortInitialiseBlocks( void ) ;
size_t xPortGetFreeHeapSize( void ) ;
size_t xPortGetMinimumEverFreeHeapSize( void ) ;
BaseType_t xPortStartScheduler( void ) ;
void vPortEndScheduler( void ) ;
    struct xMEMORY_REGION;
    void vPortStoreTaskMPUSettings( xMPU_SETTINGS * xMPUSettings,
                                    const struct xMEMORY_REGION * const xRegions,
                                    StackType_t * pxBottomOfStack,
                                    uint32_t ulStackDepth ) ;
struct xSTATIC_LIST_ITEM
{
    TickType_t xDummy2;
    void * pvDummy3[ 4 ];
};
typedef struct xSTATIC_LIST_ITEM StaticListItem_t;
struct xSTATIC_MINI_LIST_ITEM
{
    TickType_t xDummy2;
    void * pvDummy3[ 2 ];
};
typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
typedef struct xSTATIC_LIST
{
    UBaseType_t uxDummy2;
    void * pvDummy3;
    StaticMiniListItem_t xDummy4;
} StaticList_t;
typedef struct xSTATIC_TCB
{
    void * pxDummy1;
        xMPU_SETTINGS xDummy2;
    StaticListItem_t xDummy3[ 2 ];
    UBaseType_t uxDummy5;
    void * pxDummy6;
    uint8_t ucDummy7[ ( 40 ) ];
        void * pxDummy8;
        void * pvDummy15[ ( 1 ) ];
        uint32_t ulDummy18[ ( 3 ) ];
        uint8_t ucDummy19[ ( 3 ) ];
        uint8_t ucDummy21;
} StaticTask_t;
typedef struct xSTATIC_QUEUE
{
    void * pvDummy1[ 3 ];
    union
    {
        void * pvDummy2;
        UBaseType_t uxDummy2;
    } u;
    StaticList_t xDummy3[ 2 ];
    UBaseType_t uxDummy4[ 3 ];
    uint8_t ucDummy5[ 2 ];
} StaticQueue_t;
typedef StaticQueue_t StaticSemaphore_t;
typedef struct xSTATIC_EVENT_GROUP
{
    TickType_t xDummy1;
    StaticList_t xDummy2;
} StaticEventGroup_t;
typedef struct xSTATIC_TIMER
{
    void * pvDummy1;
    StaticListItem_t xDummy2;
    TickType_t xDummy3;
    void * pvDummy5;
    TaskFunction_t pvDummy6;
    uint8_t ucDummy8;
} StaticTimer_t;
typedef struct xSTATIC_STREAM_BUFFER
{
    size_t uxDummy1[ 4 ];
    void * pvDummy2[ 3 ];
    uint8_t ucDummy3;
} StaticStreamBuffer_t;
typedef StaticStreamBuffer_t StaticMessageBuffer_t;
struct xLIST;
struct xLIST_ITEM
{
     TickType_t xItemValue;
    struct xLIST_ITEM *  pxNext;
    struct xLIST_ITEM *  pxPrevious;
    void * pvOwner;
    struct xLIST *  pvContainer;
};
typedef struct xLIST_ITEM ListItem_t;
struct xMINI_LIST_ITEM
{
     TickType_t xItemValue;
    struct xLIST_ITEM *  pxNext;
    struct xLIST_ITEM *  pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;
typedef struct xLIST
{
    volatile UBaseType_t uxNumberOfItems;
    ListItem_t *  pxIndex;
    MiniListItem_t xListEnd;
} List_t;
void vListInitialise( List_t * const pxList ) ;
void vListInitialiseItem( ListItem_t * const pxItem ) ;
void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem ) ;
void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem ) ;
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
struct tskTaskControlBlock;
typedef struct tskTaskControlBlock * TaskHandle_t;
typedef BaseType_t (* TaskHookFunction_t)( void * );
typedef enum
{
    eRunning = 0,
    eReady,
    eBlocked,
    eSuspended,
    eDeleted,
    eInvalid
} eTaskState;
typedef enum
{
    eNoAction = 0,
    eSetBits,
    eIncrement,
    eSetValueWithOverwrite,
    eSetValueWithoutOverwrite
} eNotifyAction;
typedef struct xTIME_OUT
{
    BaseType_t xOverflowCount;
    TickType_t xTimeOnEntering;
} TimeOut_t;
typedef struct xMEMORY_REGION
{
    void * pvBaseAddress;
    uint32_t ulLengthInBytes;
    uint32_t ulParameters;
} MemoryRegion_t;
typedef struct xTASK_PARAMETERS
{
    TaskFunction_t pvTaskCode;
    const char * pcName;
    uint16_t usStackDepth;
    void * pvParameters;
    UBaseType_t uxPriority;
    StackType_t * puxStackBuffer;
    MemoryRegion_t xRegions[ ( ( ( ( 16UL ) - 2 ) - ( 13UL - 1UL ) ) + 1 ) ];
        StaticTask_t * const pxTaskBuffer;
} TaskParameters_t;
typedef struct xTASK_STATUS
{
    TaskHandle_t xHandle;
    const char * pcTaskName;
    UBaseType_t xTaskNumber;
    eTaskState eCurrentState;
    UBaseType_t uxCurrentPriority;
    UBaseType_t uxBasePriority;
    uint32_t ulRunTimeCounter;
    StackType_t * pxStackBase;
    uint16_t usStackHighWaterMark;
} TaskStatus_t;
typedef enum
{
    eAbortSleep = 0,
    eStandardSleep,
    eNoTasksWaitingTimeout
} eSleepModeStatus;
    TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
                                    const char * const pcName,
                                    const uint32_t ulStackDepth,
                                    void * const pvParameters,
                                    UBaseType_t uxPriority,
                                    StackType_t * const puxStackBuffer,
                                    StaticTask_t * const pxTaskBuffer ) ;
    BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
                                      TaskHandle_t * pxCreatedTask ) ;
    BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
                                            TaskHandle_t * pxCreatedTask ) ;
void vTaskAllocateMPURegions( TaskHandle_t xTask,
                              const MemoryRegion_t * const pxRegions ) ;
void vTaskDelete( TaskHandle_t xTaskToDelete ) ;
void vTaskDelay( const TickType_t xTicksToDelay ) ;
BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                            const TickType_t xTimeIncrement ) ;
BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask ) ;
UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask ) ;
eTaskState eTaskGetState( TaskHandle_t xTask ) ;
void vTaskGetInfo( TaskHandle_t xTask,
                   TaskStatus_t * pxTaskStatus,
                   BaseType_t xGetFreeStackSpace,
                   eTaskState eState ) ;
void vTaskPrioritySet( TaskHandle_t xTask,
                       UBaseType_t uxNewPriority ) ;
void vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
void vTaskResume( TaskHandle_t xTaskToResume ) ;
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
void vTaskStartScheduler( void ) ;
void vTaskEndScheduler( void ) ;
void vTaskSuspendAll( void ) ;
BaseType_t xTaskResumeAll( void ) ;
TickType_t xTaskGetTickCount( void ) ;
TickType_t xTaskGetTickCountFromISR( void ) ;
UBaseType_t uxTaskGetNumberOfTasks( void ) ;
char * pcTaskGetName( TaskHandle_t xTaskToQuery ) ;
TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) ;
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
uint16_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) ;
    void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                            BaseType_t xIndex,
                                            void * pvValue ) ;
    void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                               BaseType_t xIndex ) ;
    void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer,
                                        StackType_t ** ppxIdleTaskStackBuffer,
                                        uint32_t * pulIdleTaskStackSize );
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
                                         void * pvParameter ) ;
TaskHandle_t xTaskGetIdleTaskHandle( void ) ;
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                  const UBaseType_t uxArraySize,
                                  uint32_t * const pulTotalRunTime ) ;
void vTaskList( char * pcWriteBuffer ) ;
void vTaskGetRunTimeStats( char * pcWriteBuffer ) ;
uint32_t ulTaskGetIdleRunTimeCounter( void ) ;
uint32_t ulTaskGetIdleRunTimePercent( void ) ;
BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                               UBaseType_t uxIndexToNotify,
                               uint32_t ulValue,
                               eNotifyAction eAction,
                               uint32_t * pulPreviousNotificationValue ) ;
BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
                                      UBaseType_t uxIndexToNotify,
                                      uint32_t ulValue,
                                      eNotifyAction eAction,
                                      uint32_t * pulPreviousNotificationValue,
                                      BaseType_t * pxHigherPriorityTaskWoken ) ;
BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,
                                   uint32_t ulBitsToClearOnEntry,
                                   uint32_t ulBitsToClearOnExit,
                                   uint32_t * pulNotificationValue,
                                   TickType_t xTicksToWait ) ;
void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                    UBaseType_t uxIndexToNotify,
                                    BaseType_t * pxHigherPriorityTaskWoken ) ;
uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,
                                  BaseType_t xClearCountOnExit,
                                  TickType_t xTicksToWait ) ;
BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                         UBaseType_t uxIndexToClear ) ;
uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                        UBaseType_t uxIndexToClear,
                                        uint32_t ulBitsToClear ) ;
void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait ) ;
BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) ;
BaseType_t xTaskIncrementTick( void ) ;
void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait ) ;
void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait ) ;
void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                      TickType_t xTicksToWait,
                                      const BaseType_t xWaitIndefinitely ) ;
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue ) ;
 void vTaskSwitchContext( void ) ;
TickType_t uxTaskResetEventItemValue( void ) ;
TaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
void vTaskMissedYield( void ) ;
BaseType_t xTaskGetSchedulerState( void ) ;
BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                          UBaseType_t uxHighestPriorityWaitingTask ) ;
UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
void vTaskSetTaskNumber( TaskHandle_t xTask,
                         const UBaseType_t uxHandle ) ;
void vTaskStepTick( const TickType_t xTicksToJump ) ;
eSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
TaskHandle_t pvTaskIncrementMutexHeldCount( void ) ;
void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
struct QueueDefinition;
typedef struct QueueDefinition   * QueueHandle_t;
typedef struct QueueDefinition   * QueueSetHandle_t;
typedef struct QueueDefinition   * QueueSetMemberHandle_t;
BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition ) ;
BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait ) ;
BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer ) ;
BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait ) ;
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
void vQueueDelete( QueueHandle_t xQueue ) ;
BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition ) ;
BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken ) ;
BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken ) ;
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                const void * pvItemToQueue,
                                BaseType_t xCoRoutinePreviouslyWoken );
BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                   void * pvBuffer,
                                   BaseType_t * pxTaskWoken );
BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                         const void * pvItemToQueue,
                         TickType_t xTicksToWait );
BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                            void * pvBuffer,
                            TickType_t xTicksToWait );
QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
                                       StaticQueue_t * pxStaticQueue ) ;
QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                             const UBaseType_t uxInitialCount ) ;
QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
                                                   const UBaseType_t uxInitialCount,
                                                   StaticQueue_t * pxStaticQueue ) ;
BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait ) ;
TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) ;
BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                     TickType_t xTicksToWait ) ;
BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex ) ;
    QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
                                             const UBaseType_t uxItemSize,
                                             uint8_t * pucQueueStorage,
                                             StaticQueue_t * pxStaticQueue,
                                             const uint8_t ucQueueType ) ;
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                           QueueSetHandle_t xQueueSet ) ;
BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                                QueueSetHandle_t xQueueSet ) ;
QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
                                            const TickType_t xTicksToWait ) ;
QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                     TickType_t xTicksToWait,
                                     const BaseType_t xWaitIndefinitely ) ;
BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue ) ;
void vQueueSetQueueNumber( QueueHandle_t xQueue,
                           UBaseType_t uxQueueNumber ) ;
UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
uint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
struct tmrTimerControl;
typedef struct tmrTimerControl * TimerHandle_t;
typedef void (* TimerCallbackFunction_t)( TimerHandle_t xTimer );
typedef void (* PendedFunction_t)( void *,
                                   uint32_t );
    TimerHandle_t xTimerCreateStatic( const char * const pcTimerName,
                                      const TickType_t xTimerPeriodInTicks,
                                      const UBaseType_t uxAutoReload,
                                      void * const pvTimerID,
                                      TimerCallbackFunction_t pxCallbackFunction,
                                      StaticTimer_t * pxTimerBuffer ) ;
void * pvTimerGetTimerID( const TimerHandle_t xTimer ) ;
void vTimerSetTimerID( TimerHandle_t xTimer,
                       void * pvNewID ) ;
BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) ;
TaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) ;
BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
                                          void * pvParameter1,
                                          uint32_t ulParameter2,
                                          BaseType_t * pxHigherPriorityTaskWoken ) ;
BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
                                   void * pvParameter1,
                                   uint32_t ulParameter2,
                                   TickType_t xTicksToWait ) ;
const char * pcTimerGetName( TimerHandle_t xTimer ) ;
void vTimerSetReloadMode( TimerHandle_t xTimer,
                          const UBaseType_t uxAutoReload ) ;
UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer ) ;
TickType_t xTimerGetPeriod( TimerHandle_t xTimer ) ;
TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer ) ;
BaseType_t xTimerCreateTimerTask( void ) ;
BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                 const BaseType_t xCommandID,
                                 const TickType_t xOptionalValue,
                                 BaseType_t * const pxHigherPriorityTaskWoken,
                                 const TickType_t xTicksToWait ) ;
    void vApplicationGetTimerTaskMemory( StaticTask_t ** ppxTimerTaskTCBBuffer,
                                         StackType_t ** ppxTimerTaskStackBuffer,
                                         uint32_t * pulTimerTaskStackSize );
struct EventGroupDef_t;
typedef struct EventGroupDef_t   * EventGroupHandle_t;
typedef TickType_t               EventBits_t;
    EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer ) ;
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait ) ;
EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear ) ;
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet ) ;
EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait ) ;
EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) ;
void vEventGroupDelete( EventGroupHandle_t xEventGroup ) ;
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet ) ;
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear ) ;
struct StreamBufferDef_t;
typedef struct StreamBufferDef_t * StreamBufferHandle_t;
size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait ) ;
size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken ) ;
size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait ) ;
size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken ) ;
void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) ;
size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) ;
size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel ) ;
BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken ) ;
BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken ) ;
StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                 size_t xTriggerLevelBytes,
                                                 BaseType_t xIsMessageBuffer ) ;
StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
                                                       size_t xTriggerLevelBytes,
                                                       BaseType_t xIsMessageBuffer,
                                                       uint8_t * const pucStreamBufferStorageArea,
                                                       StaticStreamBuffer_t * const pxStaticStreamBuffer ) ;
size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t MPU_xTaskCreate( TaskFunction_t pxTaskCode,
                            const char * const pcName,
                            const uint16_t usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask ) ;
TaskHandle_t MPU_xTaskCreateStatic( TaskFunction_t pxTaskCode,
                                    const char * const pcName,
                                    const uint32_t ulStackDepth,
                                    void * const pvParameters,
                                    UBaseType_t uxPriority,
                                    StackType_t * const puxStackBuffer,
                                    StaticTask_t * const pxTaskBuffer ) ;
BaseType_t MPU_xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
                                      TaskHandle_t * pxCreatedTask ) ;
BaseType_t MPU_xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
                                            TaskHandle_t * pxCreatedTask ) ;
void MPU_vTaskAllocateMPURegions( TaskHandle_t xTask,
                                  const MemoryRegion_t * const pxRegions ) ;
void MPU_vTaskDelete( TaskHandle_t xTaskToDelete ) ;
void MPU_vTaskDelay( const TickType_t xTicksToDelay ) ;
BaseType_t MPU_xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement ) ;
BaseType_t MPU_xTaskAbortDelay( TaskHandle_t xTask ) ;
UBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t xTask ) ;
eTaskState MPU_eTaskGetState( TaskHandle_t xTask ) ;
void MPU_vTaskGetInfo( TaskHandle_t xTask,
                       TaskStatus_t * pxTaskStatus,
                       BaseType_t xGetFreeStackSpace,
                       eTaskState eState ) ;
void MPU_vTaskPrioritySet( TaskHandle_t xTask,
                           UBaseType_t uxNewPriority ) ;
void MPU_vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
void MPU_vTaskResume( TaskHandle_t xTaskToResume ) ;
void MPU_vTaskStartScheduler( void ) ;
void MPU_vTaskSuspendAll( void ) ;
BaseType_t MPU_xTaskResumeAll( void ) ;
TickType_t MPU_xTaskGetTickCount( void ) ;
UBaseType_t MPU_uxTaskGetNumberOfTasks( void ) ;
char * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery ) ;
TaskHandle_t MPU_xTaskGetHandle( const char * pcNameToQuery ) ;
UBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
uint16_t MPU_uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) ;
void MPU_vTaskSetApplicationTaskTag( TaskHandle_t xTask,
                                     TaskHookFunction_t pxHookFunction ) ;
TaskHookFunction_t MPU_xTaskGetApplicationTaskTag( TaskHandle_t xTask ) ;
void MPU_vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                            BaseType_t xIndex,
                                            void * pvValue ) ;
void * MPU_pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                               BaseType_t xIndex ) ;
BaseType_t MPU_xTaskCallApplicationTaskHook( TaskHandle_t xTask,
                                             void * pvParameter ) ;
TaskHandle_t MPU_xTaskGetIdleTaskHandle( void ) ;
UBaseType_t MPU_uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                      const UBaseType_t uxArraySize,
                                      uint32_t * const pulTotalRunTime ) ;
uint32_t MPU_ulTaskGetIdleRunTimeCounter( void ) ;
uint32_t MPU_ulTaskGetIdleRunTimePercent( void ) ;
void MPU_vTaskList( char * pcWriteBuffer ) ;
void MPU_vTaskGetRunTimeStats( char * pcWriteBuffer ) ;
BaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue ) ;
BaseType_t MPU_xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait ) ;
uint32_t MPU_ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait ) ;
BaseType_t MPU_xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear ) ;
uint32_t MPU_ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear ) ;
BaseType_t MPU_xTaskIncrementTick( void ) ;
TaskHandle_t MPU_xTaskGetCurrentTaskHandle( void ) ;
void MPU_vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
BaseType_t MPU_xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                     TickType_t * const pxTicksToWait ) ;
void MPU_vTaskMissedYield( void ) ;
BaseType_t MPU_xTaskGetSchedulerState( void ) ;
BaseType_t MPU_xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) ;
BaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue,
                                  const void * const pvItemToQueue,
                                  TickType_t xTicksToWait,
                                  const BaseType_t xCopyPosition ) ;
BaseType_t MPU_xQueueReceive( QueueHandle_t xQueue,
                              void * const pvBuffer,
                              TickType_t xTicksToWait ) ;
BaseType_t MPU_xQueuePeek( QueueHandle_t xQueue,
                           void * const pvBuffer,
                           TickType_t xTicksToWait ) ;
BaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue,
                                    TickType_t xTicksToWait ) ;
UBaseType_t MPU_uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
UBaseType_t MPU_uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
void MPU_vQueueDelete( QueueHandle_t xQueue ) ;
QueueHandle_t MPU_xQueueCreateMutex( const uint8_t ucQueueType ) ;
QueueHandle_t MPU_xQueueCreateMutexStatic( const uint8_t ucQueueType,
                                           StaticQueue_t * pxStaticQueue ) ;
QueueHandle_t MPU_xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount ) ;
QueueHandle_t MPU_xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
                                                       const UBaseType_t uxInitialCount,
                                                       StaticQueue_t * pxStaticQueue ) ;
TaskHandle_t MPU_xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
BaseType_t MPU_xQueueTakeMutexRecursive( QueueHandle_t xMutex,
                                         TickType_t xTicksToWait ) ;
BaseType_t MPU_xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
void MPU_vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcName ) ;
void MPU_vQueueUnregisterQueue( QueueHandle_t xQueue ) ;
const char * MPU_pcQueueGetName( QueueHandle_t xQueue ) ;
QueueHandle_t MPU_xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType ) ;
QueueHandle_t MPU_xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
                                             const UBaseType_t uxItemSize,
                                             uint8_t * pucQueueStorage,
                                             StaticQueue_t * pxStaticQueue,
                                             const uint8_t ucQueueType ) ;
QueueSetHandle_t MPU_xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
BaseType_t MPU_xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                               QueueSetHandle_t xQueueSet ) ;
BaseType_t MPU_xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                                    QueueSetHandle_t xQueueSet ) ;
QueueSetMemberHandle_t MPU_xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
                                                const TickType_t xTicksToWait ) ;
BaseType_t MPU_xQueueGenericReset( QueueHandle_t xQueue,
                                   BaseType_t xNewQueue ) ;
void MPU_vQueueSetQueueNumber( QueueHandle_t xQueue,
                               UBaseType_t uxQueueNumber ) ;
UBaseType_t MPU_uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
uint8_t MPU_ucQueueGetQueueType( QueueHandle_t xQueue ) ;
TimerHandle_t MPU_xTimerCreate( const char * const pcTimerName,
                                const TickType_t xTimerPeriodInTicks,
                                const UBaseType_t uxAutoReload,
                                void * const pvTimerID,
                                TimerCallbackFunction_t pxCallbackFunction ) ;
TimerHandle_t MPU_xTimerCreateStatic( const char * const pcTimerName,
                                      const TickType_t xTimerPeriodInTicks,
                                      const UBaseType_t uxAutoReload,
                                      void * const pvTimerID,
                                      TimerCallbackFunction_t pxCallbackFunction,
                                      StaticTimer_t * pxTimerBuffer ) ;
void * MPU_pvTimerGetTimerID( const TimerHandle_t xTimer ) ;
void MPU_vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID ) ;
BaseType_t MPU_xTimerIsTimerActive( TimerHandle_t xTimer ) ;
TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle( void ) ;
BaseType_t MPU_xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
                                       void * pvParameter1,
                                       uint32_t ulParameter2,
                                       TickType_t xTicksToWait ) ;
const char * MPU_pcTimerGetName( TimerHandle_t xTimer ) ;
void MPU_vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload ) ;
UBaseType_t MPU_uxTimerGetReloadMode( TimerHandle_t xTimer ) ;
TickType_t MPU_xTimerGetPeriod( TimerHandle_t xTimer ) ;
TickType_t MPU_xTimerGetExpiryTime( TimerHandle_t xTimer ) ;
BaseType_t MPU_xTimerCreateTimerTask( void ) ;
BaseType_t MPU_xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait ) ;
EventGroupHandle_t MPU_xEventGroupCreate( void ) ;
EventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer ) ;
EventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                     const EventBits_t uxBitsToWaitFor,
                                     const BaseType_t xClearOnExit,
                                     const BaseType_t xWaitForAllBits,
                                     TickType_t xTicksToWait ) ;
EventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                      const EventBits_t uxBitsToClear ) ;
EventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                    const EventBits_t uxBitsToSet ) ;
EventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToSet,
                                 const EventBits_t uxBitsToWaitFor,
                                 TickType_t xTicksToWait ) ;
void MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup ) ;
UBaseType_t MPU_uxEventGroupGetNumber( void * xEventGroup ) ;
size_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                              const void * pvTxData,
                              size_t xDataLengthBytes,
                              TickType_t xTicksToWait ) ;
size_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                                 void * pvRxData,
                                 size_t xBufferLengthBytes,
                                 TickType_t xTicksToWait ) ;
size_t MPU_xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer ) ;
void MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) ;
size_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) ;
size_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) ;
BaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                             size_t xTriggerLevel ) ;
StreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer ) ;
StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
                                                           size_t xTriggerLevelBytes,
                                                           BaseType_t xIsMessageBuffer,
                                                           uint8_t * const pucStreamBufferStorageArea,
                                                           StaticStreamBuffer_t * const pxStaticStreamBuffer ) ;
extern BaseType_t xPortRaisePrivilege( void ) ;
    BaseType_t MPU_xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
                                                TaskHandle_t * pxCreatedTask )
    {
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskCreateRestrictedStatic( pxTaskDefinition, pxCreatedTask );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    TaskHandle_t MPU_xTaskCreateStatic( TaskFunction_t pxTaskCode,
                                        const char * const pcName,
                                        const uint32_t ulStackDepth,
                                        void * const pvParameters,
                                        UBaseType_t uxPriority,
                                        StackType_t * const puxStackBuffer,
                                        StaticTask_t * const pxTaskBuffer )
    {
        TaskHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskCreateStatic( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
void MPU_vTaskAllocateMPURegions( TaskHandle_t xTask,
                                  const MemoryRegion_t * const xRegions )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    vTaskAllocateMPURegions( xTask, xRegions );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
}
    void MPU_vTaskDelete( TaskHandle_t pxTaskToDelete )
    {
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        vTaskDelete( pxTaskToDelete );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    }
    BaseType_t MPU_xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                    TickType_t xTimeIncrement )
    {
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        BaseType_t xReturn;
        xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    BaseType_t MPU_xTaskAbortDelay( TaskHandle_t xTask )
    {
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskAbortDelay( xTask );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    UBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t pxTask )
    {
        UBaseType_t uxReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        uxReturn = uxTaskPriorityGet( pxTask );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return uxReturn;
    }
    void MPU_vTaskPrioritySet( TaskHandle_t pxTask,
                               UBaseType_t uxNewPriority )
    {
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        vTaskPrioritySet( pxTask, uxNewPriority );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    }
    eTaskState MPU_eTaskGetState( TaskHandle_t pxTask )
    {
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        eTaskState eReturn;
        eReturn = eTaskGetState( pxTask );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return eReturn;
    }
    TaskHandle_t MPU_xTaskGetIdleTaskHandle( void )
    {
        TaskHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskGetIdleTaskHandle();
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    void MPU_vTaskSuspend( TaskHandle_t pxTaskToSuspend )
    {
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        vTaskSuspend( pxTaskToSuspend );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    }
    void MPU_vTaskResume( TaskHandle_t pxTaskToResume )
    {
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        vTaskResume( pxTaskToResume );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    }
void MPU_vTaskSuspendAll( void )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    vTaskSuspendAll();
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
}
BaseType_t MPU_xTaskResumeAll( void )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xTaskResumeAll();
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
TickType_t MPU_xTaskGetTickCount( void )
{
    TickType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xTaskGetTickCount();
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
UBaseType_t MPU_uxTaskGetNumberOfTasks( void )
{
    UBaseType_t uxReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    uxReturn = uxTaskGetNumberOfTasks();
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return uxReturn;
}
char * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery )
{
    char * pcReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    pcReturn = pcTaskGetName( xTaskToQuery );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return pcReturn;
}
    TaskHandle_t MPU_xTaskGetHandle( const char * pcNameToQuery )
    {
        TaskHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskGetHandle( pcNameToQuery );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    void MPU_vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
                                                BaseType_t xIndex,
                                                void * pvValue )
    {
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        vTaskSetThreadLocalStoragePointer( xTaskToSet, xIndex, pvValue );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    }
    void * MPU_pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
                                                   BaseType_t xIndex )
    {
        void * pvReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        pvReturn = pvTaskGetThreadLocalStoragePointer( xTaskToQuery, xIndex );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return pvReturn;
    }
BaseType_t MPU_xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xTaskCatchUpTicks( xTicksToCatchUp );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
    UBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
    {
        UBaseType_t uxReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        uxReturn = uxTaskGetStackHighWaterMark( xTask );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return uxReturn;
    }
    TaskHandle_t MPU_xTaskGetCurrentTaskHandle( void )
    {
        TaskHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskGetCurrentTaskHandle();
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    BaseType_t MPU_xTaskGetSchedulerState( void )
    {
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskGetSchedulerState();
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
void MPU_vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    vTaskSetTimeOutState( pxTimeOut );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
}
BaseType_t MPU_xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                     TickType_t * const pxTicksToWait )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
    BaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                       UBaseType_t uxIndexToNotify,
                                       uint32_t ulValue,
                                       eNotifyAction eAction,
                                       uint32_t * pulPreviousNotificationValue )
    {
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    BaseType_t MPU_xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,
                                           uint32_t ulBitsToClearOnEntry,
                                           uint32_t ulBitsToClearOnExit,
                                           uint32_t * pulNotificationValue,
                                           TickType_t xTicksToWait )
    {
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    uint32_t MPU_ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,
                                          BaseType_t xClearCountOnExit,
                                          TickType_t xTicksToWait )
    {
        uint32_t ulReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return ulReturn;
    }
    BaseType_t MPU_xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                                 UBaseType_t uxIndexToClear )
    {
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xTaskGenericNotifyStateClear( xTask, uxIndexToClear );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
    uint32_t MPU_ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                                UBaseType_t uxIndexToClear,
                                                uint32_t ulBitsToClear )
    {
        uint32_t ulReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        ulReturn = ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return ulReturn;
    }
    QueueHandle_t MPU_xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
                                                 const UBaseType_t uxItemSize,
                                                 uint8_t * pucQueueStorage,
                                                 StaticQueue_t * pxStaticQueue,
                                                 const uint8_t ucQueueType )
    {
        QueueHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
BaseType_t MPU_xQueueGenericReset( QueueHandle_t pxQueue,
                                   BaseType_t xNewQueue )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xQueueGenericReset( pxQueue, xNewQueue );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
BaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue,
                                  const void * const pvItemToQueue,
                                  TickType_t xTicksToWait,
                                  BaseType_t xCopyPosition )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
UBaseType_t MPU_uxQueueMessagesWaiting( const QueueHandle_t pxQueue )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    UBaseType_t uxReturn;
    uxReturn = uxQueueMessagesWaiting( pxQueue );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return uxReturn;
}
UBaseType_t MPU_uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    UBaseType_t uxReturn;
    uxReturn = uxQueueSpacesAvailable( xQueue );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return uxReturn;
}
BaseType_t MPU_xQueueReceive( QueueHandle_t pxQueue,
                              void * const pvBuffer,
                              TickType_t xTicksToWait )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    BaseType_t xReturn;
    xReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
BaseType_t MPU_xQueuePeek( QueueHandle_t xQueue,
                           void * const pvBuffer,
                           TickType_t xTicksToWait )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    BaseType_t xReturn;
    xReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
BaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue,
                                    TickType_t xTicksToWait )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    BaseType_t xReturn;
    xReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
void MPU_vQueueDelete( QueueHandle_t xQueue )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    vQueueDelete( xQueue );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
}
    EventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer )
    {
        EventGroupHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xEventGroupCreateStatic( pxEventGroupBuffer );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
EventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                     const EventBits_t uxBitsToWaitFor,
                                     const BaseType_t xClearOnExit,
                                     const BaseType_t xWaitForAllBits,
                                     TickType_t xTicksToWait )
{
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
EventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                      const EventBits_t uxBitsToClear )
{
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
EventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                    const EventBits_t uxBitsToSet )
{
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
EventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToSet,
                                 const EventBits_t uxBitsToWaitFor,
                                 TickType_t xTicksToWait )
{
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
void MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    vEventGroupDelete( xEventGroup );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
}
size_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                              const void * pvTxData,
                              size_t xDataLengthBytes,
                              TickType_t xTicksToWait )
{
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
size_t MPU_xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
size_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                                 void * pvRxData,
                                 size_t xBufferLengthBytes,
                                 TickType_t xTicksToWait )
{
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
void MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    vStreamBufferDelete( xStreamBuffer );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
}
BaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferIsFull( xStreamBuffer );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
BaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferIsEmpty( xStreamBuffer );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
BaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferReset( xStreamBuffer );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
size_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferSpacesAvailable( xStreamBuffer );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
size_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferBytesAvailable( xStreamBuffer );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
BaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                             size_t xTriggerLevel )
{
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    xReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );
    if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
    return xReturn;
}
    StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
                                                               size_t xTriggerLevelBytes,
                                                               BaseType_t xIsMessageBuffer,
                                                               uint8_t * const pucStreamBufferStorageArea,
                                                               StaticStreamBuffer_t * const pxStaticStreamBuffer )
    {
        StreamBufferHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        xReturn = xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer );
        if( xRunningPrivileged == 0 ) { __asm( " CPS #0x10" ); };
        return xReturn;
    }
